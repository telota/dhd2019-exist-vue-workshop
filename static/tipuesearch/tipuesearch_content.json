{"pages":[{"title":"eXist-db und VueJS f\u00fcr dynamische UI-Komponenten","text":"DHD Workshop 2019 DHD Workshop 2019","tags":"","url":"index.html"},{"title":"Bevor es losgeht","text":"Bevor es losgeht Ein kleiner Hinweis Voraussetzungen Bevor es losgeht Ein kleiner Hinweis Diese Dokumentation dient als Orientierung f\u00fcr den Workshop eXist-db und VueJS f\u00fcr dynamische UI-Komponenten auf der DHd-Konferenz 2019 in Mainz\/Frankfurt am Main. W\u00e4hrend des Workshops stellen wir die n\u00f6tige Infrastruktur zum Mitmachen bereit. Danach k\u00f6nnen die Inhalte weiterhin nachvollzogen werden, indem man sich die n\u00f6tigen Tools selbst auf dem eigenen Rechner installiert. Bis 05.04. - Infrastruktur nachnutzen Ab 05.04. - Tools selbst installieren Dieser Leitfaden ist darauf ausgerichtet, dass die Inhalte selbst vollzogen werden k\u00f6nnen. Voraussetzungen Folgende Kenntnisse werden vorausgesetzt: Grundlegende Kenntnisse in HTML, XML und JavaScript Folgende Software sollte installiert sein: Ein moderner Browser, z.B. Mozilla Firefox oder Google Chrome (nicht Internet Explorer!) Ein Code-Editor, z.B. Visual Studio Code, Atom oder Notepad++ Eine Java-Installation (siehe Systemvoraussetzungen) eXist-db (Einrichtungsanleitung) quoteSalute App in der eXist-db (Einrichtungsanleitung)","tags":"","url":"Vorab\/Bevor_es_losgeht.html"},{"title":"quoteSalute","text":"quoteSalute quoteSalute TODO","tags":"","url":"Vorab\/quoteSalute.html"},{"title":"Der quoteSalute XML Korpus","text":"Der quoteSalute XML Korpus Der quoteSalute XML Korpus TODO","tags":"","url":"Vorab\/Der_quoteSalute_XML_Korpus.html"},{"title":"Softwarearchitektur","text":"Softwarearchitektur Softwarearchitektur TODO","tags":"","url":"Vorab\/Softwarearchitektur.html"},{"title":"eXist-db Installation","text":"eXist-db Installation Systemvoraussetzungen Installation eXist-db starten eXist-db Installation Um an quoteSalute arbeiten zu k\u00f6nnen, muss zun\u00e4chst eXist-db und dann die quoteSalute.DB App installiert werden. In diese Anleitung sind alle notwendigen Schritte beschrieben. Systemvoraussetzungen eXist-db l\u00e4uft mit Java und funktioniert somit auf allen aktuellen Linux, macOS und Windows Betriebsystemen. Folgende Voraussetzungen sind erforderlich: mindestens Java 8 (Installations-Anleitungen finden Sie hier: Java-Downloads f\u00fcr alle Betriebssysteme) ca. 200Mb Festplattenkapazit\u00e4t ca. 512Mb Arbeitsspeicher F\u00fcr einige Schritte sind administrative Rechte erforderlich. Hinweis: Pr\u00fcfen Sie vorab, ob Java 8 installiert ist und andere\/\u00e4ltere Versionen von eXist-db vollst\u00e4ndig deinstalliert sind. Installation Gehen Sie auf Homepage von eXist-db und klicken Sie auf &quot;Download eXist-db&quot;. Es wird eine .jar-Datei heruntergeladen mit dem Namen eXist-db-setup-[version].jar (z.B. eXist-db-setup-4.6.1.jar). Gehen Sie in den Downloadordner und f\u00fchren Sie die .jar-Datei aus: bei Windows und Mac doppelt klicken bei Linux rechtsklick und dann auf &quot;mit Java ausf\u00fchren&quot; klicken oder \u00fcber die Kommandozeile: java -jar eXist-db-setup-[version].jar Nun \u00f6ffnet sich ein Installationsassitent. Wir empfehlen die Standardeinstellungen beizubehalten. Klicken Sie auf &quot;Next&quot;. Sie werden nach folgenden Schritten gefragt: Installationsordner: w\u00e4hlen Sie einen Pfad und klicken Sie auf &quot;Next&quot;. Datenordner w\u00e4hlen Sie einen Pfad und klicken Sie auf &quot;Next&quot;. Admin Passwort und Memory Einstellungen: geben Sie hier ein Passwort Ihrer Wahl ein. Dieses wird sp\u00e4ter bei bestimmten Aktionen in eXist-db ben\u00f6tigt. Hinweis: das Freilassen stellt ein Sicherheitsrisiko dar und ist deshalb nicht zu empfehlen. Package Installation: Klicken Sie &quot;Next&quot; Nun erfolgt die package installation. Klicken Sie anschlie\u00dfend auf &quot;Next&quot; Nun erfolgen weitere Installationen. Klicken Sie anschlie\u00dfend auf &quot;Next&quot;. W\u00e4hlen Sie Ihre pr\u00e4ferierten Shortcuts und klicken Sie anschlie\u00dfend auf &quot;Next&quot; Bei erfolgreicher Installation wird dieses Fenster angezeigt: eXist-db starten Um eXist-db zu starten, f\u00fchren Sie die exist.jar in ihrem Installationsordner aus. Es \u00f6ffnet sich nun ein Fenster: Das eXist-db Icon findet sich nun in Ihrer Symbolleiste. Zum \u00d6ffnen des Men\u00fcs klicken Sie auf das Icon . Klicken Sie auf &quot;install as a Service&quot; falls dies nicht bereits erfolgt ist.","tags":"","url":"eXist-db_Setup\/eXist-db_Installation.html"},{"title":"quoteSalute Installation","text":"quoteSalute Installation Weitere Informationen quoteSalute Installation Gehen Sie auf das Github-Repository von quoteSalute und speichern Sie die Datei quoteSalute.db-[version].xar lokal ab. \u00d6ffnen Sie das eXist-db Men\u00fc (klick auf das Icon in der Symbolleiste) und klicken Sie auf &quot;Open Dashboard&quot;. Ihr Standardbrowser (vorzugsweise Firefox oder Chrome) sollte sich nun \u00f6ffnen und das eXist-db Dashboard anzeigen . Standardm\u00e4\u00dfig ist die lokal installierte eXist-db-Instanz unter der folgenden URL: http:\/\/localhost:8080 zu erreichen. Geben Sie nun Ihre Admin-Nutzerdaten ein: User: admin Password: [Ihr Passwort, das Sie bei der Installation vergeben haben] \u00d6ffnen Sie die Package Manager App. Klicken Sie auf den Button add a package, ziehen Sie die gespeicherte Datei quoteSalute.db-\u3008version\u3009.xar in das Fenster Upload Packages oder klicken Sie auf Upload und w\u00e4hlen die xar-Datei \u00fcber Ihr Dateiexplorer aus und schlie\u00dfen Sie das Fenster Package Manager. Im Dashboard sehen Sie nun die quoteSalute.DB App. Weitere Informationen Java-Downloads f\u00fcr alle Betriebssysteme eXist-db Basic Installation eXist-db Troubleshooting","tags":"","url":"eXist-db_Setup\/quoteSalute_Installation.html"},{"title":"\u00dcbersicht","text":"\u00dcbersicht \u00dcbersicht In diesem Kapitel werden Sie lernen, wie man in eXist-db eXide bedient, den quoteSalute-XML-Korpus mit TEI abfragt, zuf\u00e4llige Gru\u00dfformeln extrahiert, XML zu JSON transformiert und Datenbankabfragen mit Filtern versieht. Es gibt zwei Challenges, um ihr gelerntes Wissen anzuwenden: Challenge 1: Eine Gru\u00dfformel abrufen Challenge 2: Ein neuer Filter","tags":"","url":"XML_zu_JSON_in_eXist-db\/\u00dcbersicht.html"},{"title":"Erste Schritte mit eXide","text":"Erste Schritte mit eXide Wichtige URLs eXide Starten Aufbau von eXide Erste Schritte mit eXide In diesem Abschnitt wird erkl\u00e4rt, wie man mit der eXist-db internen IDE (Integrated Development Environment; dt. Entwicklungsumgebung) Dateien innerhalb eines eXist-db-Projekts bearbeitet. Wichtige URLs Bei einer lokalen Standardinstallation sollten Sie die folgenden Teilbereiche der Applikation unter folgenden URLs erreichen: eXist-Dashboard - http:\/\/localhost:8080\/exist\/apps\/dashboard\/index.html eXide - http:\/\/localhost:8080\/exist\/apps\/eXide\/index.html quoteSalute - http:\/\/localhost:8080\/exist\/apps\/quoteSalute\/salute.html eXide Starten Gehen Sie auf das eXist-db Dashboard. Klicken Sie auf eXide. Es sollte sich nun ein neuer Browsertab mit eXide \u00f6ffnen. Aufbau von eXide Dateibrowser (directory) - Hier k\u00f6nnen Sie die Dateien in der eXist-db browsen und mit Doppelklick \u00f6ffnen. Toolbar - Die meisten Buttons sind selbsterkl\u00e4rend. a. Eval-Button - F\u00fchrt ein ge\u00f6ffnetes .xql-Skript aus. b. Run-Button - Startet die ge\u00f6ffnete App. Datei-Tabs - Navigation zwischen den von Ihnen ge\u00f6ffneten Dateien. Editor-Bereich - Hier k\u00f6nnen Sie den Quellcode der Dateien bearbeiten. Ergebnis-Bereich - Dieser Bereich \u00f6ffnet sich, nachdem man auf Eval gedr\u00fcckt hat. Hier werden die Ergebnisse angezeigt.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Erste_Schritte_mit_eXide.html"},{"title":"Den quoteSalute Korpus abfragen","text":"Den quoteSalute Korpus abfragen abfrage.xql - Das quoteSalute-Back-End Einfache Datenbankabfrage Ergebnisse in eXide Ergebnisse im Browser Den quoteSalute Korpus abfragen Die Datenbankabfragen bei quoteSalute werden \u00fcber die Datei abfrage.xql abgewickelt. In diesem Abschnitt wird eine sehr vereinfachte Version dieser Datei erkl\u00e4rt, um die Funktionsweise Schritt f\u00fcr Schritt zu erl\u00e4utern. abfrage.xql - Das quoteSalute-Back-End \u00d6ffnen Sie eXide \u00fcber Ihr eXist-Dashboard. Siehe dazu auch: Wichtige URLS \u00d6ffnen Sie im Dateibrowser die Datei \/db\/apps\/quotesalute\/abfrage-tutorial-01.xql Einfache Datenbankabfrage Der folgende Code-Schnipsel bezieht sich auf die Datei abfrage-tutorial-01.xql. Innerhalb von eXist-db wird mit der funktionalen Programmiersprache XQuery gearbeitet. Die dazugeh\u00f6rige Dateiendung ist .xql. Im folgenden Code-Beispiel passiert folgendes: xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: Hole alle TEI-Daten aus dem Korpus :) return collection($data)\/\/tei:TEI (: Kommentar :) - Angaben die mit (: beginnen und :) aufh\u00f6ren sind sog. Kommentare. Diese helfen den Code besser zu lesen. Sie haben keinen Einfluss auf den auszuf\u00fchrenden Code. Z. 1: Deklaration der XQuery-Version. Dies hilft der eXist-db den Code zu durchleuchten und den m\u00f6glichen Funktionsumfang des Codes richtig einzusch\u00e4tzen. Z. 3: Es wird der TEI-Namensraum deklariert. Namensr\u00e4ume in XML-Daten helfen, den XML-Elementen eine bereits vordefinierte Bedeutung zu verleihen. So wird z.B. mit dem Namensraum-Tag (Element) &lt;tei:lb\/&gt; sichergestellt, dass es sich um einen Zeilenumbruch (Line Break) handelt, und nicht um eine etwaige Nutzung von lb als Gewichtheinheit Pfund. Z. 5: Der Pfad zu der Arbeitskollektion von quoteSalute wird in der Variable $data hinterlegt. Z. 7: Das Ergebnis der gesamten Operation. Hier wird der gesamte quoteSalute-Korpus durchsucht. Dabei sollen alle Elemente aus allen Dateien ausgeliefert werden \/\/, die den Tag-Namen tei:TEI haben. Ergebnisse in eXide Sie k\u00f6nnen sich die XML-Ergebnisse direkt in eXide anzeigen lassen. Lesen Sie sich den Code durch Dr\u00fccken Sie auf den Eval-Button in der Toolbar. Es erscheint unter dem Editor-Bereich ein Ergebnisbereich. Dort werden Ihnen die abfragten Daten angezeigt. Siehe auch Aufbau von eXide. Ergebnisse im Browser Sie k\u00f6nnen sich die XML-Ergebnisse auch anders \u00fcber Ihren Browser anzeigen lassen. \u00d6ffnen Sie einen neuen Browsertab. Geben Sie folgende URL ein: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-01.xql. In diesem Fall erhalten Sie noch kein wohlgeformtes XML zur\u00fcck. Weiter mit Schritt 4. Lassen Sie sich den Seitenquelltext anzeigen um ans rohe XML zu gelangen. a. Firefox und Chrome - Strg + U oder Rechtsklick -&gt; Seitenquelltext anzeigen.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Den_quoteSalute_Korpus_abfragen.html"},{"title":"Challenge 1 - Eine Gru\u00dfformel abrufen","text":"Challenge 1: Eine Gru\u00dfformel abrufen Aufgabe Gegeben L\u00f6sungsstrategien Challenge 1: Eine Gru\u00dfformel abrufen Aufgabe Versuchen Sie die Datenbankabfrage in der Datei abfrage-challenge-01.xql so zu manipulieren, dass nur noch eine einzige Gru\u00dfformel (die erste) zur\u00fcckgeliefert wird. Gegeben abfrage-challenge-01.xql Die Datei ist schon so manipuliert, dass nur der 3. Treffer aus einer Trefferkollektion zur\u00fcckgegeben wird. xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: TODO: Die erste Gru\u00dfformel aus dem quoteSalute Korpus holen :) return (collection($data)\/\/tei:TEI)[3] L\u00f6sungsstrategien \u00d6ffnen Sie die Datei abfrage-challenge-01.xql mit eXide. Schauen Sie sich eine der Dateien im quoteSalute-Korpus an. Der Pfad ist in der $data-Variable hinterlegt. \u00d6ffnen Sie mit eXide eine Datei aus diesem Pfad. Schauen Sie sich die XML-Struktur an. Identifizieren Sie den Namen des XML-Elements, welches eine Gru\u00dfformel samt seiner Metadaten umschlie\u00dft. Passen Sie das return-Statement in der XQuery-Datei in eXide an.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_1_-_Eine_Gru\u00dfformel_abrufen.html"},{"title":"Challenge 1 - L\u00f6sung","text":"Challenge 1: L\u00f6sung Erl\u00e4uterung Challenge 1: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 1. xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: TODO: Das erste Zitat aus dem quoteSalute Korpus holen :) return (collection($data)\/\/tei:cit)[1] Erl\u00e4uterung Das Element, welches alle Informationen zu einem Zitat beinhaltet ist tei:cit. Hole alle tei:cit-Elemente wird zu \/\/tei:cit. Die eckigen Klammern am Ende deuten an, welche Position in der Ergebnisliste zur\u00fcckgegeben werden soll. Vorher: [3] - 3. Position Nachher: [1] - 1. Position","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_1_-_L\u00f6sung.html"},{"title":"Eine zuf\u00e4llige Gru\u00dfformel generieren","text":"Eine zuf\u00e4llige Gru\u00dfformel generieren Neuerungen im Code Erl\u00e4uterungen Code Eine zuf\u00e4llige Gru\u00dfformel generieren In diesem Abschnitt wird die Erkl\u00e4rung zur Datei abfrage.xql erweitert. Es wird gezeigt, wie ein zuf\u00e4lliges Element aus einer Ergebniskollektion ausgew\u00e4hlt werden kann. Neuerungen im Code \u00d6ffnen Sie die Datei abfrage-tutorial-02.xql in eXide. Schauen Sie sich Code und Kommentare an. F\u00fchren Sie den Code aus. Lassen Sie sich das Ergebnis in eXide oder im Browser anzeigen. Was hat sich im Vergleich zu abfrage-tutorial-01.xql ge\u00e4ndert? Erl\u00e4uterungen Z. 9: Wir speichern vorerst alle Ergebnisse in eine Variable $greetings. let $greetings := collection($data)\/\/tei:cit Z. 12: Wir z\u00e4hlen erst alle Ergebnisse mit count($greetings). Mit util:random() wird dann eine zuf\u00e4llige Zahl zwischen 0 und der Anzahl der Ergebnisse ausgew\u00e4hlt. let $random := util:random(count($greetings)) Z. 15-18: XQuery kann mit einer &quot;0. Position&quot; nichts anfangen. Dieser Code-Block stellt sicher, dass die Zufallszahl mindestens 1 ist. In anderen Worten: Wenn die Zufallszahl gr\u00f6\u00dfer oder gleich 1 ist, liefere die Zufallszahl zur\u00fcck. Falls nicht (also 0 oder kleiner), liefere 1 zur\u00fcck. let $cleanRandom := if ($random &gt;= 1) then $random else 1 Z. 21: W\u00e4hle die Gru\u00dfformel an der zuf\u00e4llig bestimmten Position aus der Ergebnisliste let $randomcit := $greetings[position()=$cleanRandom] Z. 24: Liefere die zuf\u00e4llige Gru\u00dfformel als XML zur\u00fcck. return $randomcit Code xquery version &quot;3.0&quot;; (: FLOWR for let order where return :) (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; let $greetings := collection($data)\/\/tei:cit (: W\u00e4hle eine zuf\u00e4llige Position aus der Ergebnisliste :) let $random := util:random(count($greetings)) (: Stelle sicher, dass auch wirklich nur ein Ergebnis ausgew\u00e4hlt wurde :) let $cleanRandom := if ($random &gt;= 1) then $random else 1 (: Hole die Gru\u00dfformel an der Stelle :) let $randomcit := $greetings[position()=$cleanRandom] (: Gib die zuf\u00e4llige Gru\u00dfformel zur\u00fcck :) return $randomcit","tags":"","url":"XML_zu_JSON_in_eXist-db\/Eine_zuf\u00e4llige_Gru\u00dfformel_generieren.html"},{"title":"XML zu JSON","text":"XML zu JSON Neuerungen im Code Erl\u00e4uterungen Code XML zu JSON In diesem Abschnitt wird die Erkl\u00e4rung zur Datei abfrage.xql erweitert. Es wird gezeigt, wie XML-Daten zu JSON serialisiert werden k\u00f6nnen. Neuerungen im Code \u00d6ffnen Sie die Datei abfrage-tutorial-03.xql in eXide. Schauen Sie sich Code und Kommentare an. F\u00fchren Sie den Code aus. Lassen Sie sich das Ergebnis in eXide oder im Browser anzeigen. Was hat sich im Vergleich zu abfrage-tutorial-02.xql ge\u00e4ndert? Erl\u00e4uterungen Z. 5-8: Wir wollen das XML-Ergebnis am Ende nach JSON serialisieren. Der output-Namensraum wird ben\u00f6tigt, um Daten in ein anderes Format zu serialisieren. Mit der Option exist:serialize zeigen wir der eXist-db an, dass sp\u00e4ter im Code eine Datenserialisierung erfolgen soll und die dementsprechenden Funktionen bereitgehalten werden sollen. declare namespace output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;; (: Serialisierung nach JSON als Ergebnisziel angeben :) declare option exist:serialize &quot;media-type=application\/json&quot;; Z. 10-27: Dies ist eine interne Helferfunktion, welche XML-Daten bereinigt. Dabei wird s\u00e4mtlicher Textinhalt aus einem Element und seinen Kinderelementen zu einem Text zusammengef\u00fcgt. Vorher Nachher &lt;div&gt;Das ist &lt;a href=&quot;#&quot;&gt;das Haus&lt;\/a&gt; vom Nikolaus.&lt;\/div&gt; &lt;div&gt;Das ist das Haus vom Nikolaus.&lt;\/div&gt; Schauen wir uns ein Beispielzitat aus dem Korpus an: &lt;cit&gt; &lt;quote ana=&quot;#formal #s-m #r-n&quot; xml:lang=&quot;deu&quot;&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/quote&gt; &lt;bibl&gt; &lt;title type=&quot;edition&quot;&gt;Jean Paul \u2013 S\u00e4mtliche Briefe digital&lt;\/title&gt; &lt;title type=&quot;letter&quot;&gt;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&lt;\/title&gt; &lt;ref target=&quot;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&quot;\/&gt; &lt;\/bibl&gt; &lt;\/cit&gt; Z. 46-52: Die Inhalte und Metadaten zur zuf\u00e4llig ausgew\u00e4hlten Gru\u00dfformel werden in separaten Variablen gespeichert. Dabei werden die Inhalte mit normalize-space() und local:clean-up() bereinigt, um z.B. Zeilenumbr\u00fcche und ggf. doppelt vorkommende Leerstellen zu entfernen. Der Inhalt der Variable $quote wird in diesem Fall dann &lt;quote&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/quote&gt; sein. Das gilt analog f\u00fcr die anderen Variablen. let $quote := element quote { normalize-space(string-join(local:clean-up($randomcit\/tei:quote))) } let $edition := element edition { normalize-space($randomcit\/\/tei:title[@type='edition']) } let $title := element title { normalize-space($randomcit\/\/tei:title[@type='letter']) } let $language := element language { normalize-space($randomcit\/\/tei:quote\/@xml:lang) } let $url := element url { $randomcit\/\/tei:bibl\/tei:ref\/@target\/data(.) } let $licence := element licence { $randomcit\/\/tei:licence\/@target\/data(.) } Z. 54: Wir erstellen ein neues Element &lt;cit&gt; mit den bereinigten Inhalten aus den Statements zuvor. let $preparedGreeting := element cit {$quote,$edition,$title,$url,$language,$licence} Der Inhalt von $preparedGreeting sollte dann mit dem Beispiel oben wie folgt aussehen: &lt;cit&gt; &lt;quote&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/quote&gt; &lt;edition&gt;Jean Paul \u2013 S\u00e4mtliche Briefe digital&lt;\/edition&gt; &lt;title&gt;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&lt;\/title&gt; &lt;url&gt;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&lt;\/url&gt; &lt;language&gt;deu&lt;\/language&gt; &lt;licence&gt;&lt;\/licence&gt; &lt;\/cit&gt; Z. 57-63: Hier werden die JSON-Serialisierungsparameter angegeben. D.h., hier wird bestimmt, wie der JSON-Output am Ende aussehen soll. let $jsonSerializationParams := &lt;output:serialization-parameters xmlns:output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;&gt; &lt;output:method value=&quot;json&quot;\/&gt; &lt;output:media-type value=&quot;application\/json&quot;\/&gt; &lt;output:json-ignore-whitespace-text-nodes value=&quot;yes&quot;\/&gt; &lt;\/output:serialization-parameters&gt; Z. 66-67: Die berenigten XML-Daten in $preparedGreeting werden mit den von uns vorgegebenen JSON-Serialisierungsparametern $jsonSerializationParams nach JSON umgeformt. return serialize($preparedGreeting, $jsonSerializationParams) Das JSON-Ergebnis sieht wie folgt aus: { &quot;quote&quot;:&quot;Mit Achtung der Ihrige&quot;, &quot;edition&quot;:&quot;August Wilhelm Ifflands dramaturgisches und administratives Archiv&quot;, &quot;title&quot;:&quot;Von Johann Gottfried Schadow. Berlin, 12. M\u00e4rz 1805. Dienstag&quot;, &quot;url&quot;:&quot;http:\/\/iffland.bbaw.de\/briefe\/detail.xql?id=A0000306&quot;, &quot;language&quot;:&quot;deu&quot;, &quot;licence&quot;:null } Code xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; declare namespace output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;; (: Serialisierung nach JSON als Ergebnisziel angeben :) declare option exist:serialize &quot;media-type=application\/json&quot;; (: Helferfunktion um Datenstrukturen zu bereinigen :) declare function local:clean-up($nodes as node()*) as xs:string* { for $node in $nodes return typeswitch($node) case element(tei:lb)|element(tei:abbr)|element(tei:reg)|element(tei:note) return () case element() return local:clean-up($node\/node()) case text() return $node default return local:clean-up($node\/node()) }; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; let $greetings := collection($data)\/\/tei:cit (: W\u00e4hle eine zuf\u00e4llige Position aus der Ergebnisliste :) let $random := util:random(count($greetings)) (: Stelle sicher, dass auch wirklich nur ein Ergebnis ausgew\u00e4hlt wurde :) let $cleanRandom := if ($random &gt;= 1) then $random else 1 (: Hole die Gru\u00dfformel an der Stelle :) let $randomcit := $greetings[position()=$cleanRandom] (: Erstelle Variablen f\u00fcr die Inhalte und Metdaten zu einer Gru\u00dfformel :) let $quote := element quote { normalize-space(string-join(local:clean-up($randomcit\/tei:quote))) } let $edition := element edition { normalize-space($randomcit\/\/tei:title[@type='edition']) } let $title := element title { normalize-space($randomcit\/\/tei:title[@type='letter']) } let $language := element language { normalize-space($randomcit\/\/tei:quote\/@xml:lang) } let $url := element url { $randomcit\/\/tei:bibl\/tei:ref\/@target\/data(.) } let $licence := element licence { $randomcit\/\/tei:licence\/@target\/data(.) } let $preparedGreeting := element cit {$quote,$edition,$title,$url,$language,$licence} (: Bestimmte wie die JSON-Serializierung aussehen soll :) let $jsonSerializationParams := &lt;output:serialization-parameters xmlns:output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;&gt; &lt;output:method value=&quot;json&quot;\/&gt; &lt;output:media-type value=&quot;application\/json&quot;\/&gt; &lt;output:json-ignore-whitespace-text-nodes value=&quot;yes&quot;\/&gt; &lt;\/output:serialization-parameters&gt; (: Serialisiere das zuf\u00e4llige XML-cit-Element nach JSON :) return serialize($preparedGreeting, $jsonSerializationParams)","tags":"","url":"XML_zu_JSON_in_eXist-db\/XML_zu_JSON.html"},{"title":"Abfragen mit Filtern","text":"Abfragen mit Filtern Neuerungen im Code URL-Parameter Einzelner Filter - Briefe von Frauen Mehrere Filter - Briefe von Frauen an Frauen (oder neutral) Erl\u00e4uterungen Code Abfragen mit Filtern In diesem Abschnitt wird die Erkl\u00e4rung zur Datei abfrage.xql erweitert. Es wird gezeigt, wie Daten aus dem quoteSalute nach bestimmten Eigenschaften gefiltert werden k\u00f6nnen, sodass z.B. nur Gru\u00dfformeln von Frauen als Absender ausgew\u00e4hlt werden. Neuerungen im Code \u00d6ffnen Sie die Datei abfrage-tutorial-04.xql in eXide. Schauen Sie sich Code und Kommentare an. F\u00fchren Sie den Code aus. Lassen Sie sich das Ergebnis in eXide oder im Browser anzeigen. Was hat sich im Vergleich zu abfrage-tutorial-03.xql ge\u00e4ndert? Wenn Sie den Code mit eXide ausf\u00fchren, sollte sich im Ergebnis nichts sichtbares ge\u00e4ndert haben. Sie k\u00f6nnen jedoch URL-Parameter angeben, um Daten zu filtern. URL-Parameter \u00dcberfliegen Sie kurz die Dokumentation von quoteSalute. Einzelner Filter - Briefe von Frauen Sie k\u00f6nnen \u00fcber die Browser-URL Parameter (nutzerspezifizierte Werte) an das quoteSalute-Back-End \u00fcbergeben. Das grundlegende Prinzip ist folgenderma\u00dfen: [URL]?parameter=wert. Mit dem ? wird angezeigt, dass Parameter \u00fcbergeben werden sollen. \u00d6ffnen Sie folgende URL in einem neuen Browser-Tab: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql Sie sollten eine Gru\u00dfformel als JSON erhalten. Erweitern Sie die URL mit ?sender=s-f. (s f\u00fcr &quot;sender&quot; und f f\u00fcr &quot;female&quot;) Ihre URL sollte jetzt http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f lauten. Im title-Feld sollten Sie nachvollziehen k\u00f6nnen, dass nur noch Gru\u00dfformeln von Briefen angezeigt werden, deren Verfasser Frauen waren. Laden Sie den Tab mit F5 neu, um sich eine andere zuf\u00e4llige Gru\u00dfformel anzeigen zu lassen. Mehrere Filter - Briefe von Frauen an Frauen (oder neutral) Sie k\u00f6nnen auch mehrere Parameter \u00fcber die Browser-URL \u00fcbergeben. Das grundlegende Prinzip ist folgenderma\u00dfen [URL]?parameter1=wert1&amp;parameter2=wert2. Mit dem &amp; werden Parameterpaare getrennt. \u00d6ffnen Sie folgende URL in einem neuen Browser-Tab: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f Sie sollten eine Gru\u00dfformel als JSON erhalten. Erweitern Sie die URL mit &amp;receiver=r-fXr-n. Ihre URL sollte jetzt http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f&amp;receiver=r-fXr-n Anhand der Daten sollten Sie nachvollziehen k\u00f6nnen, dass nur noch Gru\u00dfformeln von Briefen angezeigt werden, deren Verfasser Frauen waren und deren Empf\u00e4nger entweder auch Frauen waren bzw. so formuliert sind, dass sich das Geschlecht des Empf\u00e4ngers nicht bestimmen l\u00e4sst. Laden Sie den Tab mit F5 neu, um sich eine andere zuf\u00e4llige Gru\u00dfformel anzeigen zu lassen. Erl\u00e4uterungen Z. 12-15: Wir teilen der eXist-db mit, dass die Werte von URL-Parametern in Variablen gespeichert werden sollen, falls diese vorkommen. Zum Beispiel wird in $sender der Wert s-f gespeichert, wenn die Anfrage von der URL http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f kommt. Folgende URL-Parameter werden akzeptiert: type - H\u00f6flichkeitsstufe sender - Geschlecht der absendenden Person receiver - Geschlecht der empfangenden Person language - Sprache, in welcher die Gru\u00dfformel verfasst wurde declare variable $type := request:get-parameter('type', ()); declare variable $sender := request:get-parameter('sender', ()); declare variable $receiver := request:get-parameter('receiver', ()); declare variable $language := request:get-parameter('language', ()); Z. 39-76: Hier werden die URL-Parameterwerte f\u00fcr eine Datenbankabfrage aufbereitet, sodass der quoteSalute-Korpus entsprechend gefiltert werden kann. In dem Code-Schnipsel werden nur type, sender und receiver aufbereitet. Der langauge-Filter ist die n\u00e4chste Challenge. In Code-Bl\u00f6cken zu $type-contains, $sender-contains und $receiver-contains werden Mehrfachnennungen der URL-Parameter aufbereitet. Z.B. wird aus dem URL-Parameter ?receiver=r-fXr-n die XQuery-Schnipsel contains(.\/\/@ana, &quot;#r-f&quot;) und contains(.\/\/@ana, &quot;#r-n&quot;). In den Code-Bl\u00f6cken zu $filter-type, $filter-sender und $filter-receiver werden diese XQuery-Schnipsel dann zu einer Filter-Datenbankanfrage zusammengef\u00fcgt. Z.B. entsteht dann folgender Wertschnipsel: contains(.\/\/@ana, &quot;#r-f&quot;) or contains(.\/\/@ana, &quot;#r-n&quot;). Also liefere nur Gru\u00dfformeln zur\u00fcck, welche im @ana-Attribut die Werte #r-f oder #r-n enthalten. (: START - H\u00f6flichkeitsfilter vorbereiten :) let $type-contains := for $item in tokenize($type, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-type := if (count($type) &gt;= 1) then let $containQuery := string-join($type-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - H\u00f6flichkeitsfilter vorbereiten :) (: START - Absenderfilter vorbereiten :) let $sender-contains := for $item in tokenize($sender, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-sender := if (count($sender) &gt;= 1) then let $containQuery := string-join($sender-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Absenderfilder vorbereiten :) (: START - Empf\u00e4ngerfilter vorbereiten :) let $receiver-contains := for $item in tokenize($receiver, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-receiver := if (count($receiver) &gt;= 1) then let $containQuery := string-join($receiver-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Empf\u00e4ngerfilter vorberiten :) Z. 78: Bereite eine Abfrage (engl. query) vor, indem die bisher bekannte Anfrage collection($data)\/\/tei:cit mit den Filtern erweitert wird. Die ||-Zeichen bedeuten, dass die Werte der dahinterliegenden Variablen und Ausdr\u00fccke an die Abfrage rangef\u00fcgt werden sollen. let $query := ('collection($data)\/\/tei:cit'||$filter-type||$filter-sender||$filter-receiver) Z. 79: Nun holen wir eine Kollektion an Gru\u00dfformeln, auf die die Filter passen. let $greetings := util:eval($query) Der Rest der Datei ist wie bisher und folgt derselben Logik. Code xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; declare namespace output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;; (: Serialisierung nach JSON als Ergebnisziel angeben :) declare option exist:serialize &quot;media-type=application\/json&quot;; (: Request-Parameter entgegenennehmen. Wenn von einer Webseite eine Anfrage kommt, : k\u00f6nnen nutzerdefinierte Angaben mit \u00fcberreicht werden. :) declare variable $type := request:get-parameter('type', ()); declare variable $sender := request:get-parameter('sender', ()); declare variable $receiver := request:get-parameter('receiver', ()); declare variable $language := request:get-parameter('language', ()); (: Helferfunktion um Datenstrukturen zu bereinigen :) declare function local:clean-up($nodes as node()*) as xs:string* { for $node in $nodes return typeswitch($node) case element(tei:lb)|element(tei:abbr)|element(tei:reg)|element(tei:note) return () case element() return local:clean-up($node\/node()) case text() return $node default return local:clean-up($node\/node()) }; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: START - H\u00f6flichkeitsfilter vorbereiten :) let $type-contains := for $item in tokenize($type, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-type := if (count($type) &gt;= 1) then let $containQuery := string-join($type-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - H\u00f6flichkeitsfilter vorbereiten :) (: START - Absenderfilter vorbereiten :) let $sender-contains := for $item in tokenize($sender, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-sender := if (count($sender) &gt;= 1) then let $containQuery := string-join($sender-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Absenderfilder vorbereiten :) (: START - Empf\u00e4ngerfilter vorbereiten :) let $receiver-contains := for $item in tokenize($receiver, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-receiver := if (count($receiver) &gt;= 1) then let $containQuery := string-join($receiver-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Empf\u00e4ngerfilter vorberiten :) let $query := ('collection($data)\/\/tei:cit'||$filter-type||$filter-sender||$filter-receiver) let $greetings := util:eval($query) (: W\u00e4hle eine zuf\u00e4llige Position aus der Ergebnisliste :) let $random := util:random(count($greetings)) (: Stelle sicher, dass auch wirklich nur ein Ergebnis ausgew\u00e4hlt wurde :) let $cleanRandom := if ($random &gt;= 1) then $random else 1 (: Hole die Gru\u00dfformel an der Stelle :) let $randomcit := $greetings[position()=$cleanRandom] (: Erstelle Variablen f\u00fcr die Inhalte und Metdaten zu einer Gru\u00dfformel :) let $quote := element quote { normalize-space(string-join(local:clean-up($randomcit\/tei:quote))) } let $edition := element edition { normalize-space($randomcit\/\/tei:title[@type='edition']) } let $title := element title { normalize-space($randomcit\/\/tei:title[@type='letter']) } let $language := element language { normalize-space($randomcit\/\/tei:quote\/@xml:lang) } let $url := element url { $randomcit\/\/tei:bibl\/tei:ref\/@target\/data(.) } let $licence := element licence { $randomcit\/\/tei:licence\/@target\/data(.) } let $preparedGreeting := element cit {$quote,$edition,$title,$url,$language,$licence} (: Bestimmte wie die JSON-Serializierung aussehen soll :) let $jsonSerializationParams := &lt;output:serialization-parameters xmlns:output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;&gt; &lt;output:method value=&quot;json&quot;\/&gt; &lt;output:media-type value=&quot;application\/json&quot;\/&gt; &lt;output:json-ignore-whitespace-text-nodes value=&quot;yes&quot;\/&gt; &lt;\/output:serialization-parameters&gt; (: Serialisiere das zuf\u00e4llige XML-cit-Element nach JSON :) return serialize($preparedGreeting, $jsonSerializationParams)","tags":"","url":"XML_zu_JSON_in_eXist-db\/Abfragen_mit_Filtern.html"},{"title":"Challenge 2 - Ein neuer Filter","text":"Challenge 2: Ein neuer Filter Aufgabe L\u00f6sungsans\u00e4tze Challenge 2: Ein neuer Filter Im Abschnitt zuvor wurden Filter zu H\u00f6flichkeit, Sender und Empf\u00e4nger eingerichtet. In dieser Challenge soll ein Sprach-Filter hinzugef\u00fcgt werden. Aufgabe Erweitern Sie die Datei abfrage-challenge-02.xql. F\u00fcgen Sie einen Sprach-Filter hinzu. Orientieren Sie sich dabei an die bisherigen Filter. \u00dcberpr\u00fcfen Sie, ob Ihr Code funktioniert, indem Sie folgende URL im Browser aufrufen: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?language=eng. Wenn Sie nach mehrmaligem Neuladen der Seite nur englische Gru\u00dfformeln angezeigt bekommen, ist ihr Code-Richtig. L\u00f6sungsans\u00e4tze In der Variable $language wird der Sprachwert gespeichert. Dieser kann leer sein, oder z.B. deu, eng oder ita sein. F\u00fchren Sie analog zu den bisherigen Filter-Schritten die Variablen $language-contains und $filter-langauge ein. Erweitern Sie die $query-Variable Ergebnis im Browser \u00fcberpr\u00fcfen.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_2_-_Ein_neuer_Filter.html"},{"title":"Challenge 2 - L\u00f6sung","text":"Challenge 2: L\u00f6sung Erl\u00e4uterung Challenge 2: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 2. Erl\u00e4uterung Analog zu den anderen Filtern wurde der Sprach-Parameter f\u00fcr eine sp\u00e4tere Datenbankabfrage aufbereitet: (: START - Sprachfilter vorbereiten :) let $language-contains := for $item in tokenize($language, 'X') return concat('contains(.\/\/@xml:lang, &quot;', $item, '&quot;)') let $filter-language := if (count($language) &gt;= 1) then let $containQuery := string-join($language-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Sprachfilter vorbereiten :) Anschlie\u00dfend wurde die $query-Datenbankabfragevariable erweitert. let $query := ('collection($data)\/\/tei:cit'||$filter-type||$filter-sender||$filter-receiver||$filter-language) Ruft man nun http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-challenge-02-solution.xql?language=eng auf, erscheinen nur Gru\u00dfformeln auf Englisch.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_2_-_L\u00f6sung.html"},{"title":"Zusammenfassung","text":"Zusammenfassung Zusammenfassung In diesem Kapitel haben Sie gelernt, wie man in eXist-db eXide bedient, den quoteSalute-XML-Korpus mit TEI abfragt, zuf\u00e4llige Gru\u00dfformeln extrahiert, XML zu JSON transformiert und Datenbankabfragen mit Filtern versieht. Sie haben Ihr Wissen getestet und folgende Challenges absolviert: Challenge 1: Eine Gru\u00dfformel abrufen Challenge 2: Ein neuer Filter Im folgenden Kapitel werden die ersten Schritte mit VueJS erkl\u00e4rt, sodass im finalen Kapitel die Verbindung von VueJS und eXist-db vollzogen werden kann. Vorerst m\u00fcssen Sie keine weiteren \u00c4nderungen mit eXide vornehmen.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Zusammenfassung.html"},{"title":"\u00dcbersicht","text":"\u00dcbersicht \u00dcbersicht In diesem Kapitel werden die Grundz\u00fcge von VueJS vorgestellt. Zuerst wird das technische Setup besprochen. F\u00fcr dieses Kapitel ben\u00f6tigen Sie grundlegendes Wissen in der Webprogrammierung mit HTML und JavaScript (kurz JS). Sie werden lernen, wie man VueJS in ein HTML-Dokument einbindet, Daten und Templates in einer VueJS-Instanz verwaltet (model binding), Templates mit if-Konditionen und for-Schleifen manipuliert, VueJS-Instanz-interne Funktionen und mit On-Click-Events interaktiv gestaltet, sowie sog. Computed Properties, d.h. sich stetig aktualisierende Variablen, anwendet. Die Code-Beispiele in diesem Kapitel sind etwas vom quoteSalute-Inhalt losgel\u00f6st. Im folgenden und finalen Kapitel werden dann eXist-db und VueJS miteinander verbunden, um das quoteSalute-Front-End zu realisieren.","tags":"","url":"Erste_Schritte_mit_VueJS\/\u00dcbersicht.html"},{"title":"Vorbereitung f\u00fcr VueJS","text":"Vorbereitung f\u00fcr VueJS Beispieldateien Software Firefox Google Chrome Vorbereitung f\u00fcr VueJS Beispieldateien Wir haben Code-Skelette zum Nachvollziehen vorbereitet. Laden Sie folgende Datei herunter DOWNLOAD ME und entpacken Sie das ZIP-Archiv auf Ihrem Rechner. Die Abh\u00e4ngigkeiten aus den Code-Beispielen werden mitgeliefert. S\u00e4mtlicher JavaScript-Code wird in einem &lt;script&gt;-Block am Ende des &lt;body&gt;-Tags verwaltet, sodass HTML und JavaScript f\u00fcr dieses Tutorial eine geschlossene Einheit bilden. Software Ein moderner Browser, z.B. Mozilla Firefox oder Google Chrome (nicht Internet Explorer!) Ein Code-Editor, z.B. Visual Studio Code, Atom oder Notepad++ Firefox Mit Firefox sollte alles problemlos funktionieren. Google Chrome Sollten Sie Google Chrome (oder Chromium) verwenden, installieren Sie bitte folgende Erweiterung: Web Server for Chrome Wenn Sie JavaScript in HTML-Dateien benutzen m\u00f6chten, die auf Ihrer lokalen Festplatte liegen, blockiert Chrome aus Sicherheitsgr\u00fcnden dessen ausf\u00fchrung. Mit dieser Erweiterung schaffen Sie lokal einen &quot;Mini-Server&quot; f\u00fcr ausgew\u00e4hlte Dateien, um JavaScript lokal im Browser auszuf\u00fchren.","tags":"","url":"Erste_Schritte_mit_VueJS\/Vorbereitung_f\u00fcr_VueJS.html"},{"title":"VueJS benutzen","text":"VueJS benutzen Grundlagen VueJS im HTML-Dokument Code VueJS benutzen In diesem Abschnitt wird kurz beschrieben, was VueJS ist und wie es benutzt werden kann. Zugeh\u00f6rige Beispieldatei: 02_VueJS_benutzen.html Grundlagen VueJS ist eine JavaScript-Software-Bibliothek, welche sich mit anderen Bibliotheken wie React oder AngularJS vergleichen l\u00e4sst. Das grundlegenste Ziel von VueJS ist es, Webseiten reaktiv zu gestalten. Die HTML-Daten werden dabei auf dem Rechner des Nutzers on-the-fly berechnet. Dabei interagieren das Datenmodell und die VueJS-DOM (VueJS-HTML-Templates) miteinander. \u00c4ndert sich ein Wert im Datenmodell, \u00e4ndern sich auch alle Anzeigen, wo dieser Wert referenziert ist. VueJS im HTML-Dokument Um VueJS im eigenen JavaScript-Code nutzen zu k\u00f6nnen, muss es im HTML-Dokument importiert werden. Derzeit ist es g\u00e4ngig JavaScript nicht im &lt;head&gt;-Element, sondern am Ende des &lt;body&gt;-Tags zu importieren. Im body-Bereich legen wir ein div-Element mit der ID root an. Dieses soll als Ziel-Element f\u00fcr unsere Vue-Instanz dienen. &lt;div id=&quot;root&quot;&gt; &lt;!-- Hier kann VueJS zugreifen--&gt; &lt;\/div&gt; Wir laden die VueJS-Bibliothek und erstellen eine neue Vue-Instanz. \u00dcber den el-Parameter teilen wir mit, auf welches Element sich die Vue-Instanz beschr\u00e4nken soll. In diesem Fall das Element mit der ID &quot;root&quot;, also #root. const vue = new Vue({ el: '#root' }); Code Zugeh\u00f6rige Beispieldatei: 02_VueJS_benutzen.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: VueJS einbinden&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;VueJS einbinden&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- Hier kann VueJS zugreifen--&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root' }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/VueJS_benutzen.html"},{"title":"Data und Templates","text":"Data und Templates Data Templates Aufgabe Code Data und Templates In diesem Abschnitt wird beschrieben, wie man das Datenmodell in einer VueJS-Instanz verwaltet und im HTML-Code nutzbar macht. Data Die Vue-Instanz \u00e4hnelt vom Aufbau einem JSON-Objekt. Das data-Element verwaltet das interne Datenmodell der Vue-Instanz. Nach dem Key-Value-Prinzip k\u00f6nnen hier neue Variablen angelegt werden. Der data-Variable name wird der Wert Alexander von Humboldt zugeordnet. Der data-Variable shoppingList eine Liste mit den Werten Bananen, Brot und Schokolade. const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ] } }); Zwar sind die Variablen nun vorhanden, jedoch noch nicht angezeigt. Templates Auf die Variablen kann im Vue-Bereich des HTML-Codes nun zugegriffen werden. Mit {{ variable }} wird der Wert einer Variable ausgegeben. {{ name }} wird also automatisch mit Alexander von Humboldt ersetzt. Man kann auch \u00fcber Listen iterieren. F\u00fcr jeden Eintrag item in der Einkaufliste shoppingList erstelle ein Listenelement &lt;li&gt; und trage dort den Wert von item ein. &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; Der gesamte Code-Schnipsel sieht also wie folgt aus. &lt;div id=&quot;root&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; &lt;\/ul&gt; &lt;\/div&gt; &lt;\/div&gt; Wenn Sie die Datei mit Ihrem Browser \u00f6ffnen, sollte folgender Output zu sehen sein. Mein Name ist Alexander von Humboldt. Meine Einkaufsliste lautet: Bananen Brot Schokolade Aufgabe \u00d6ffnen Sie die Datei 03_Data_und_Templates.html mit ihrem Browser (rechtsklick -&gt; \u00d6ffnen mit...) \u00d6ffnen Sie die Datei 03_Data_und_Templates.html mit einem Text-Editor. \u00c4ndern Sie die Werte im data-Element in der Vue-Instanz. F\u00fcgen Sie weitere Werte zur Einkaufsliste hinzu. Speichern Sie das HTML-Dokument. Laden Sie die Seite in Ihrem Browser neu. Haben sich die Werte ge\u00e4ndert? Code Zugeh\u00f6rige Beispieldatei: 03_Data_und_Templates.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: Data und Templates&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;Data und Templates&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; &lt;\/ul&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ] } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/Data_und_Templates.html"},{"title":"\u00dcbersicht","text":"\u00dcbersicht \u00dcbersicht TODO","tags":"","url":"eXist-db_und_VueJS\/\u00dcbersicht.html"}]}