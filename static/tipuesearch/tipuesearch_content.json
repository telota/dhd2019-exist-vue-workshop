{"pages":[{"title":"eXist-db und VueJS f\u00fcr dynamische UI-Komponenten","text":"DHD Workshop 2019 DHD Workshop 2019","tags":"","url":"index.html"},{"title":"Bevor es losgeht","text":"Bevor es losgeht Ein kleiner Hinweis Voraussetzungen Bevor es losgeht Ein kleiner Hinweis Diese Dokumentation dient als Orientierung f\u00fcr den Workshop eXist-db und VueJS f\u00fcr dynamische UI-Komponenten auf der DHd-Konferenz 2019 in Mainz\/Frankfurt am Main. W\u00e4hrend des Workshops stellen wir die n\u00f6tige Infrastruktur zum Mitmachen bereit. Danach k\u00f6nnen die Inhalte weiterhin nachvollzogen werden, indem man sich die n\u00f6tigen Tools selbst auf dem eigenen Rechner installiert. Bis 05.04. - Infrastruktur nachnutzen Ab 05.04. - Tools selbst installieren Dieser Leitfaden ist darauf ausgerichtet, dass die Inhalte selbst vollzogen werden k\u00f6nnen. Voraussetzungen Folgende Kenntnisse werden vorausgesetzt: Grundlegende Kenntnisse in HTML, XML und JavaScript Folgende Software sollte installiert sein: Ein moderner Browser, z.B. Mozilla Firefox oder Google Chrome (nicht Internet Explorer!) Ein Code-Editor, z.B. Visual Studio Code, Atom oder Notepad++ Eine Java-Installation (siehe Systemvoraussetzungen) eXist-db (Einrichtungsanleitung) quoteSalute App in der eXist-db (Einrichtungsanleitung)","tags":"","url":"Vorab\/Bevor_es_losgeht.html"},{"title":"quoteSalute","text":"quoteSalute Links Literatur quoteSalute In den Digital Humanities werden in den letzten Jahren immer mehr digitale Briefeditionen erstellt, von denen viele bereits ihre Daten als TEI-XML offen und kostenlos bereitstellen. Das Projekt quoteSalute erprobt das kreative Potential dieser offenen Forschungsdaten, indem es Gru\u00dfformeln der Brieftexte aus verschiedenen Editionen aggregiert und \u00fcber eine Webseite bereitstellt, von wo aus sie per Knopfdruck in die eigene E-Mail-Korrespondenz kopiert werden k\u00f6nnen. Nutzer*innen k\u00f6nnen so Briefabschl\u00fcsse historisch interessanter Pers\u00f6nlichkeiten zitieren und diese f\u00fcr ihre eigene allt\u00e4gliche Korrespondenz verwenden. quoteSalute entstand als studentisches Projekt der TELOTA-Initiative im M\u00e4rz 2018 an der Berlin-Brandenburgische Akademie der Wissenschaften mit dem Ziel, die editorische Arbeit digitaler Editionen \u00fcber den wissenschaftlichen Diskurs hinaus auf kreative Weise auszusch\u00f6pfen und ihr dadurch mehr \u00f6ffentliche Pr\u00e4senz zu verschaffen. Durch die Nachnutzung der Forschungsdaten in quoteSalute werden die historischen Gru\u00dfformeln spielerisch in den Alltagskontext des E-Mail-Schreibens integrierbar, wobei trotz Neu-Kontextualisierung der Gru\u00dfformeln die Verbindung zur \u201cUrsprungsedition\u201d durch eine Verlinkung bestehen bleibt, sodass sich bei einer breiteren Verwendung der Applikation die digitalen Editionen einer gr\u00f6\u00dferen Bekanntheit erfreuen d\u00fcrfen. quoteSalute wurde im September 2018 mit dem DARIAH-DE DH-Award ausgezeichnet, das SWR 2 \u201cJournal am Mittag\u201d berichtet au\u00dferdem in einem Feature \u00fcber das Projekt. Das Generieren der Gru\u00dfformeln als Webapplikation wurde mit HTML, CSS (Bootstrap) und dem Javascript Front-End-Framework VueJS realisiert. Die Daten werden in eXist-db vorgehalten, die Datenbankabfrage erfolgt mittels XQuery und die Response-Daten werden im JSON-Format ausgegeben. quoteSalute ist \u00fcber die Webseite des DfG-Projekts \u201ccorrespSearch - Briefeditionen vernetzen\u201d (Dumont 2016) verf\u00fcgbar. Daten, Code und Dokumentation stehen \u00fcber ein GitHub-Repositorium unter freien Lizenzen bereit. Interessierte Editionsvorhaben sind dazu eingeladen, selbst Datens\u00e4tze beizusteuern. Links Projektwebseite: quoteSalute.net Github: https:\/\/github.com\/telota\/quoteSalute Blogbeitrag zum DARIAH-Award: https:\/\/dhd-blog.org\/?p=10534 Bericht beim SWR 2: https:\/\/www.ardmediathek.de\/tv\/SWR2-Journal-am-Mittag\/Die-Website-quoteSalute\/SWR2\/Audio?bcastId=8757898&amp;documentId=53957190 [letzter Zugriff am 04.10.2018] Literatur Dumont, Stefan: \u201ccorrespSearch \u2013 Connecting Scholarly Editions of Letters\u201d. In: Journal of Text Encoding Initiative. Issue 10. 2016.","tags":"","url":"Vorab\/quoteSalute.html"},{"title":"Das quoteSalute XML Korpus","text":"Das quoteSalute XML Korpus Literatur Das quoteSalute XML Korpus Als \u201eIndikator f\u00fcr die Beziehungen, die der Briefschreiber zu dem -empf\u00e4nger hat oder zu haben glaubt\u201c (Ermert 1979: 104) sind und waren Gru\u00dfformeln wesentliche Elemente der schriftlichen Kommunikation, insbesondere des Briefes. Deshalb bieten die Richtlinien der Text Encoding Initiative (TEI) mit dem Element &lt;salute&gt; auch seit langem eine entsprechende Kodierungsm\u00f6glichkeit (TEI-Konsortium 2018). F\u00fcr quoteSalute werden Gru\u00dfformeln anhand des &lt;salute&gt;-Elements aus TEI-XML-kodierten Briefeditionen extrahiert und in die TEI-XML basierte Struktur des quoteSalute-Austauschformats konvertiert. F\u00fcr jede Breifedition, die in das Korpus integriert werden soll, wird eine XML-Datei angelegt. Diese besteht aus einem &lt;teiHeader&gt; mit den Metadaten (zum Beispiel wo die Daten herstammen) und einem &lt;body&gt;, der eine Liste aus &lt;cit&gt;-Elementen enth\u00e4lt. Jedes &lt;cit&gt; enth\u00e4lt dann die Gru\u00dfformel, sowie Angaben zum urspr\u00fcnglichen Brief und zur jeweiligen Edition. Eine Tabellen mit detaillierte Informationen \u00fcber die Struktur der ben\u00f6tigten TEI-XML-Datei, die f\u00fcr eine Einbindung von Gru\u00dfformeln in quoteSalute erforderlich ist, finden Sie in der Dokumentation auf der Projektwebseite. Hier ein Beispiel einer Gru\u00dfformel im Korpus: &lt;cit&gt; &lt;quote xml:lang=&quot;deu&quot; ana=&quot;#formal #s-m #r-m&quot;&gt;Leb wohl.&lt;\/quote&gt; &lt;bibl&gt; &lt;title type=&quot;edition&quot;&gt;Briefe und Texte aus dem intellektuellen Berlin um 1800&lt;\/title&gt; &lt;title type=&quot;letter&quot;&gt;Brief von Adelbert von Chamisso an Louis de La Foye (ohne Ort, Ende Oktober 1804)&lt;\/title&gt; &lt;ref target=&quot;http:\/\/www.berliner-intellektuelle.eu\/manuscript?Brief008ChamissoandeLaFoye.xml&quot;\/&gt; &lt;\/bibl&gt; &lt;\/cit&gt; Anschlie\u00dfenden erfolgt eine manuellen Kuratierung. Die Daten werden von Wiederholungen und unpassenden Inhalten bereinigt und mit weiterer semantischer Information angereichert. Letzteres erm\u00f6glicht ein sp\u00e4teres Filtern nach: Formalit\u00e4t: Informell bzw. freundschaftlich oder formal Geschlecht der Korrespondierenden wie es grammatikalisch aus der Quelle hervorgeht: neutral, weiblich oder m\u00e4nnlich Sprache: bisher sieben verschiedene, darunter Deutsch, Englisch, Italienisch und Latein Jede Gru\u00dfformel erh\u00e4lt ein @xml:lang mit der entsprechenden Sprache und ein @ana, welches Informationen \u00fcber Geschlecht und Grad der Formalit\u00e4t enth\u00e4lt. Das folgende Beispiel zeigt, wie das Tagging zur semantischen Anreicherung der Gru\u00dfformeln umgesetzt wurde: &lt;quote xml:lang=&quot;deu&quot; ana=&quot;#formal #s-n #r-n&quot;&gt;Bis dahin empfiehlt sich Ihrem Wohlwollen hochachtungsvoll&lt;\/quote&gt; Die hier getaggte Gru\u00dfformel ist in deutscher Sprache, von formellem Charakter und impliziert sowohl f\u00fcr Sender und Empf\u00e4nger kein erkennbares Geschlecht. Das Korpus von quoteSalute umfasst derzeit 981 Gru\u00dfformeln aus 14 verschiedenen Briefeditionen (Stand M\u00e4rz 2019), unter anderem aus den Editionen \u201cBriefe und Texte aus dem intellektuellen Berlin um 1800\u201d (Balliot o.J.), \u201cDigitale Edition der Briefe Erdmuthe Benignas von Reu\u00df-Ebersdorf (1670-1732)\u201d (Prell\/Schmidt-Funke 2017) und \u201cDER STURM. Digitale Quellenedition zur Geschichte der internationalen Avantgarde\u201d (Trautmann \/ Schrade 2018). Alle Editionen haben ihre Daten unter einer freien Lizenzen zur Verf\u00fcgung gestellt. Literatur Baillot, Anne (Ed.) (o.J.): Briefe und Texte aus dem intellektuellen Berlin um 1800. Berlin: Humboldt-Universit\u00e4t zu Berlin. www.berliner-intellektuelle.eu\/ [letzter Zugriff am 04.10.2018] Ermert, Karl (1979). Briefsorten. Untersuchungen zu Theorie und Empirie der Textklassifikation. T\u00fcbingen: Niemeyer. Prell, Martin \/ Schmidt-Funke, Julia (Eds.) (2017): Digitale Edition der Briefe Erdmuthe Benignas von Reu\u00df-Ebersdorf (1670-1732). Jena [Work in Progress]. http:\/\/erdmuthe.thulb.uni-jena.de [letzter Zugriff am 04.10.2018] TEI Consortium (2018). . TEI P5: Guidelines for Electronic Text Encoding and Interchange. [Version 3.4.0 23rd July 2018]. http:\/\/www.tei-c.org\/release\/doc\/tei-p5-doc\/en\/html\/ref-salute.html [letzter Zugriff am 04.10.2018] Trautmann, Marjam \/ Schrade, Torsten (Eds.) (2018): DER STURM. Digitale Quellenedition zur Geschichte der internationalen Avantgarde. Mainz: Akademie der Wissenschaften und der Literatur. https:\/\/sturm-edition.de\/quellen\/briefe.html [letzter Zugriff am 04.10.2018]","tags":"","url":"Vorab\/Das_quoteSalute_XML_Korpus.html"},{"title":"Softwarearchitektur","text":"Softwarearchitektur Softwarearchitektur","tags":"","url":"Vorab\/Softwarearchitektur.html"},{"title":"eXist-db Installation","text":"eXist-db Installation Systemvoraussetzungen Installation eXist-db starten eXist-db Installation Um an quoteSalute arbeiten zu k\u00f6nnen, muss zun\u00e4chst eXist-db und dann die quoteSalute.DB App installiert werden. In diese Anleitung sind alle notwendigen Schritte beschrieben. Systemvoraussetzungen eXist-db l\u00e4uft mit Java und funktioniert somit auf allen aktuellen Linux, macOS und Windows Betriebsystemen. Folgende Voraussetzungen sind erforderlich: mindestens Java 8 (Installations-Anleitungen finden Sie hier: Java-Downloads f\u00fcr alle Betriebssysteme) ca. 200Mb Festplattenkapazit\u00e4t ca. 512Mb Arbeitsspeicher F\u00fcr einige Schritte sind administrative Rechte erforderlich. Hinweis: Pr\u00fcfen Sie vorab, ob Java 8 installiert ist und andere\/\u00e4ltere Versionen von eXist-db vollst\u00e4ndig deinstalliert sind. Installation Gehen Sie auf Homepage von eXist-db und klicken Sie auf &quot;Download eXist-db&quot;. Es wird eine .jar-Datei heruntergeladen mit dem Namen eXist-db-setup-[version].jar (z.B. eXist-db-setup-4.6.1.jar). Gehen Sie in den Downloadordner und f\u00fchren Sie die .jar-Datei aus: bei Windows und Mac doppelt klicken bei Linux rechtsklick und dann auf &quot;mit Java ausf\u00fchren&quot; klicken oder \u00fcber die Kommandozeile: java -jar eXist-db-setup-[version].jar Nun \u00f6ffnet sich ein Installationsassitent. Wir empfehlen die Standardeinstellungen beizubehalten. Klicken Sie auf &quot;Next&quot;. Sie werden nach folgenden Schritten gefragt: Installationsordner: w\u00e4hlen Sie einen Pfad und klicken Sie auf &quot;Next&quot;. Datenordner w\u00e4hlen Sie einen Pfad und klicken Sie auf &quot;Next&quot;. Admin Passwort und Memory Einstellungen: geben Sie hier ein Passwort Ihrer Wahl ein. Dieses wird sp\u00e4ter bei bestimmten Aktionen in eXist-db ben\u00f6tigt. Hinweis: das Freilassen stellt ein Sicherheitsrisiko dar und ist deshalb nicht zu empfehlen. Package Installation: Klicken Sie &quot;Next&quot; Nun erfolgt die package installation. Klicken Sie anschlie\u00dfend auf &quot;Next&quot; Nun erfolgen weitere Installationen. Klicken Sie anschlie\u00dfend auf &quot;Next&quot;. W\u00e4hlen Sie Ihre pr\u00e4ferierten Shortcuts und klicken Sie anschlie\u00dfend auf &quot;Next&quot; Bei erfolgreicher Installation wird dieses Fenster angezeigt: eXist-db starten Um eXist-db zu starten, f\u00fchren Sie die exist.jar in ihrem Installationsordner aus. Es \u00f6ffnet sich nun ein Fenster: Das eXist-db Icon findet sich nun in Ihrer Symbolleiste. Zum \u00d6ffnen des Men\u00fcs klicken Sie auf das Icon . Klicken Sie auf &quot;install as a Service&quot; falls dies nicht bereits erfolgt ist.","tags":"","url":"eXist-db_Setup\/eXist-db_Installation.html"},{"title":"quoteSalute Installation","text":"quoteSalute Installation Weitere Informationen quoteSalute Installation Gehen Sie auf das Github-Repository von quoteSalute und speichern Sie die Datei quoteSalute.db-[version].xar lokal ab. \u00d6ffnen Sie das eXist-db Men\u00fc (klick auf das Icon in der Symbolleiste) und klicken Sie auf &quot;Open Dashboard&quot;. Ihr Standardbrowser (vorzugsweise Firefox oder Chrome) sollte sich nun \u00f6ffnen und das eXist-db Dashboard anzeigen . Standardm\u00e4\u00dfig ist die lokal installierte eXist-db-Instanz unter der folgenden URL: http:\/\/localhost:8080 zu erreichen. Geben Sie nun Ihre Admin-Nutzerdaten ein: User: admin Password: [Ihr Passwort, das Sie bei der Installation vergeben haben] \u00d6ffnen Sie die Package Manager App. Klicken Sie auf den Button add a package, ziehen Sie die gespeicherte Datei quoteSalute.db-\u3008version\u3009.xar in das Fenster Upload Packages oder klicken Sie auf Upload und w\u00e4hlen die xar-Datei \u00fcber Ihr Dateiexplorer aus und schlie\u00dfen Sie das Fenster Package Manager. Im Dashboard sehen Sie nun die quoteSalute.DB App. Weitere Informationen Java-Downloads f\u00fcr alle Betriebssysteme eXist-db Basic Installation eXist-db Troubleshooting","tags":"","url":"eXist-db_Setup\/quoteSalute_Installation.html"},{"title":"\u00dcbersicht","text":"\u00dcbersicht \u00dcbersicht In diesem Kapitel werden Sie lernen, wie man in eXist-db eXide bedient, den quoteSalute-XML-Korpus mit TEI abfragt, zuf\u00e4llige Gru\u00dfformeln extrahiert, XML zu JSON transformiert und Datenbankabfragen mit Filtern versieht. Es gibt zwei Challenges, um ihr gelerntes Wissen anzuwenden: Challenge 1: Eine Gru\u00dfformel abrufen Challenge 2: Ein neuer Filter","tags":"","url":"XML_zu_JSON_in_eXist-db\/\u00dcbersicht.html"},{"title":"Erste Schritte mit eXide","text":"Erste Schritte mit eXide Wichtige URLs eXide Starten Aufbau von eXide Erste Schritte mit eXide In diesem Abschnitt wird erkl\u00e4rt, wie man mit der eXist-db internen IDE (Integrated Development Environment; dt. Entwicklungsumgebung) Dateien innerhalb eines eXist-db-Projekts bearbeitet. Wichtige URLs Bei einer lokalen Standardinstallation sollten Sie die folgenden Teilbereiche der Applikation unter folgenden URLs erreichen: eXist-Dashboard - http:\/\/localhost:8080\/exist\/apps\/dashboard\/index.html eXide - http:\/\/localhost:8080\/exist\/apps\/eXide\/index.html quoteSalute - http:\/\/localhost:8080\/exist\/apps\/quoteSalute\/salute.html eXide Starten Gehen Sie auf das eXist-db Dashboard. Klicken Sie auf eXide. Es sollte sich nun ein neuer Browsertab mit eXide \u00f6ffnen. Aufbau von eXide Dateibrowser (directory) - Hier k\u00f6nnen Sie die Dateien in der eXist-db browsen und mit Doppelklick \u00f6ffnen. Toolbar - Die meisten Buttons sind selbsterkl\u00e4rend. a. Eval-Button - F\u00fchrt ein ge\u00f6ffnetes .xql-Skript aus. b. Run-Button - Startet die ge\u00f6ffnete App. Datei-Tabs - Navigation zwischen den von Ihnen ge\u00f6ffneten Dateien. Editor-Bereich - Hier k\u00f6nnen Sie den Quellcode der Dateien bearbeiten. Ergebnis-Bereich - Dieser Bereich \u00f6ffnet sich, nachdem man auf Eval gedr\u00fcckt hat. Hier werden die Ergebnisse angezeigt.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Erste_Schritte_mit_eXide.html"},{"title":"Den quoteSalute Korpus abfragen","text":"Den quoteSalute Korpus abfragen abfrage.xql - Das quoteSalute-Back-End Einfache Datenbankabfrage Ergebnisse in eXide Ergebnisse im Browser Den quoteSalute Korpus abfragen Die Datenbankabfragen bei quoteSalute werden \u00fcber die Datei abfrage.xql abgewickelt. In diesem Abschnitt wird eine sehr vereinfachte Version dieser Datei erkl\u00e4rt, um die Funktionsweise Schritt f\u00fcr Schritt zu erl\u00e4utern. abfrage.xql - Das quoteSalute-Back-End \u00d6ffnen Sie eXide \u00fcber Ihr eXist-Dashboard. Siehe dazu auch: Wichtige URLS \u00d6ffnen Sie im Dateibrowser die Datei \/db\/apps\/quotesalute\/abfrage-tutorial-01.xql Einfache Datenbankabfrage Der folgende Code-Schnipsel bezieht sich auf die Datei abfrage-tutorial-01.xql. Innerhalb von eXist-db wird mit der funktionalen Programmiersprache XQuery gearbeitet. Die dazugeh\u00f6rige Dateiendung ist .xql. Im folgenden Code-Beispiel passiert folgendes: xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: Hole alle TEI-Daten aus dem Korpus :) return collection($data)\/\/tei:TEI (: Kommentar :) - Angaben die mit (: beginnen und :) aufh\u00f6ren sind sog. Kommentare. Diese helfen den Code besser zu lesen. Sie haben keinen Einfluss auf den auszuf\u00fchrenden Code. Z. 1: Deklaration der XQuery-Version. Dies hilft der eXist-db den Code zu durchleuchten und den m\u00f6glichen Funktionsumfang des Codes richtig einzusch\u00e4tzen. Z. 3: Es wird der TEI-Namensraum deklariert. Namensr\u00e4ume in XML-Daten helfen, den XML-Elementen eine bereits vordefinierte Bedeutung zu verleihen. So wird z.B. mit dem Namensraum-Tag (Element) &lt;tei:lb\/&gt; sichergestellt, dass es sich um einen Zeilenumbruch (Line Break) handelt, und nicht um eine etwaige Nutzung von lb als Gewichtheinheit Pfund. Z. 5: Der Pfad zu der Arbeitskollektion von quoteSalute wird in der Variable $data hinterlegt. Z. 7: Das Ergebnis der gesamten Operation. Hier wird der gesamte quoteSalute-Korpus durchsucht. Dabei sollen alle Elemente aus allen Dateien ausgeliefert werden \/\/, die den Tag-Namen tei:TEI haben. Ergebnisse in eXide Sie k\u00f6nnen sich die XML-Ergebnisse direkt in eXide anzeigen lassen. Lesen Sie sich den Code durch Dr\u00fccken Sie auf den Eval-Button in der Toolbar. Es erscheint unter dem Editor-Bereich ein Ergebnisbereich. Dort werden Ihnen die abfragten Daten angezeigt. Siehe auch Aufbau von eXide. Ergebnisse im Browser Sie k\u00f6nnen sich die XML-Ergebnisse auch anders \u00fcber Ihren Browser anzeigen lassen. \u00d6ffnen Sie einen neuen Browsertab. Geben Sie folgende URL ein: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-01.xql. In diesem Fall erhalten Sie noch kein wohlgeformtes XML zur\u00fcck. Weiter mit Schritt 4. Lassen Sie sich den Seitenquelltext anzeigen um ans rohe XML zu gelangen. a. Firefox und Chrome - Strg + U oder Rechtsklick -&gt; Seitenquelltext anzeigen.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Den_quoteSalute_Korpus_abfragen.html"},{"title":"Challenge 1 - Eine Gru\u00dfformel abrufen","text":"Challenge 1: Eine Gru\u00dfformel abrufen Aufgabe Gegeben L\u00f6sungsstrategien Challenge 1: Eine Gru\u00dfformel abrufen Aufgabe Versuchen Sie die Datenbankabfrage in der Datei abfrage-challenge-01.xql so zu manipulieren, dass nur noch eine einzige Gru\u00dfformel (die erste) zur\u00fcckgeliefert wird. Gegeben abfrage-challenge-01.xql Die Datei ist schon so manipuliert, dass nur der 3. Treffer aus einer Trefferkollektion zur\u00fcckgegeben wird. xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: TODO: Die erste Gru\u00dfformel aus dem quoteSalute Korpus holen :) return (collection($data)\/\/tei:TEI)[3] L\u00f6sungsstrategien \u00d6ffnen Sie die Datei abfrage-challenge-01.xql mit eXide. Schauen Sie sich eine der Dateien im quoteSalute-Korpus an. Der Pfad ist in der $data-Variable hinterlegt. \u00d6ffnen Sie mit eXide eine Datei aus diesem Pfad. Schauen Sie sich die XML-Struktur an. Identifizieren Sie den Namen des XML-Elements, welches eine Gru\u00dfformel samt seiner Metadaten umschlie\u00dft. Passen Sie das return-Statement in der XQuery-Datei in eXide an.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_1_-_Eine_Gru\u00dfformel_abrufen.html"},{"title":"Challenge 1 - L\u00f6sung","text":"Challenge 1: L\u00f6sung Erl\u00e4uterung Challenge 1: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 1. xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: TODO: Das erste Zitat aus dem quoteSalute Korpus holen :) return (collection($data)\/\/tei:cit)[1] Erl\u00e4uterung Das Element, welches alle Informationen zu einem Zitat beinhaltet ist tei:cit. Hole alle tei:cit-Elemente wird zu \/\/tei:cit. Die eckigen Klammern am Ende deuten an, welche Position in der Ergebnisliste zur\u00fcckgegeben werden soll. Vorher: [3] - 3. Position Nachher: [1] - 1. Position","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_1_-_L\u00f6sung.html"},{"title":"Eine zuf\u00e4llige Gru\u00dfformel generieren","text":"Eine zuf\u00e4llige Gru\u00dfformel generieren Neuerungen im Code Erl\u00e4uterungen Code Eine zuf\u00e4llige Gru\u00dfformel generieren In diesem Abschnitt wird die Erkl\u00e4rung zur Datei abfrage.xql erweitert. Es wird gezeigt, wie ein zuf\u00e4lliges Element aus einer Ergebniskollektion ausgew\u00e4hlt werden kann. Neuerungen im Code \u00d6ffnen Sie die Datei abfrage-tutorial-02.xql in eXide. Schauen Sie sich Code und Kommentare an. F\u00fchren Sie den Code aus. Lassen Sie sich das Ergebnis in eXide oder im Browser anzeigen. Was hat sich im Vergleich zu abfrage-tutorial-01.xql ge\u00e4ndert? Erl\u00e4uterungen Z. 9: Wir speichern vorerst alle Ergebnisse in eine Variable $greetings. let $greetings := collection($data)\/\/tei:cit Z. 12: Wir z\u00e4hlen erst alle Ergebnisse mit count($greetings). Mit util:random() wird dann eine zuf\u00e4llige Zahl zwischen 0 und der Anzahl der Ergebnisse ausgew\u00e4hlt. let $random := util:random(count($greetings)) Z. 15-18: XQuery kann mit einer &quot;0. Position&quot; nichts anfangen. Dieser Code-Block stellt sicher, dass die Zufallszahl mindestens 1 ist. In anderen Worten: Wenn die Zufallszahl gr\u00f6\u00dfer oder gleich 1 ist, liefere die Zufallszahl zur\u00fcck. Falls nicht (also 0 oder kleiner), liefere 1 zur\u00fcck. let $cleanRandom := if ($random &gt;= 1) then $random else 1 Z. 21: W\u00e4hle die Gru\u00dfformel an der zuf\u00e4llig bestimmten Position aus der Ergebnisliste let $randomcit := $greetings[position()=$cleanRandom] Z. 24: Liefere die zuf\u00e4llige Gru\u00dfformel als XML zur\u00fcck. return $randomcit Code xquery version &quot;3.0&quot;; (: FLOWR for let order where return :) (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; let $greetings := collection($data)\/\/tei:cit (: W\u00e4hle eine zuf\u00e4llige Position aus der Ergebnisliste :) let $random := util:random(count($greetings)) (: Stelle sicher, dass auch wirklich nur ein Ergebnis ausgew\u00e4hlt wurde :) let $cleanRandom := if ($random &gt;= 1) then $random else 1 (: Hole die Gru\u00dfformel an der Stelle :) let $randomcit := $greetings[position()=$cleanRandom] (: Gib die zuf\u00e4llige Gru\u00dfformel zur\u00fcck :) return $randomcit","tags":"","url":"XML_zu_JSON_in_eXist-db\/Eine_zuf\u00e4llige_Gru\u00dfformel_generieren.html"},{"title":"XML zu JSON","text":"XML zu JSON Neuerungen im Code Erl\u00e4uterungen Code XML zu JSON In diesem Abschnitt wird die Erkl\u00e4rung zur Datei abfrage.xql erweitert. Es wird gezeigt, wie XML-Daten zu JSON serialisiert werden k\u00f6nnen. Neuerungen im Code \u00d6ffnen Sie die Datei abfrage-tutorial-03.xql in eXide. Schauen Sie sich Code und Kommentare an. F\u00fchren Sie den Code aus. Lassen Sie sich das Ergebnis in eXide oder im Browser anzeigen. Was hat sich im Vergleich zu abfrage-tutorial-02.xql ge\u00e4ndert? Erl\u00e4uterungen Z. 5-8: Wir wollen das XML-Ergebnis am Ende nach JSON serialisieren. Der output-Namensraum wird ben\u00f6tigt, um Daten in ein anderes Format zu serialisieren. Mit der Option exist:serialize zeigen wir der eXist-db an, dass sp\u00e4ter im Code eine Datenserialisierung erfolgen soll und die dementsprechenden Funktionen bereitgehalten werden sollen. declare namespace output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;; (: Serialisierung nach JSON als Ergebnisziel angeben :) declare option exist:serialize &quot;media-type=application\/json&quot;; Z. 10-27: Dies ist eine interne Helferfunktion, welche XML-Daten bereinigt. Dabei wird s\u00e4mtlicher Textinhalt aus einem Element und seinen Kinderelementen zu einem Text zusammengef\u00fcgt. Vorher Nachher &lt;div&gt;Das ist &lt;a href=&quot;#&quot;&gt;das Haus&lt;\/a&gt; vom Nikolaus.&lt;\/div&gt; &lt;div&gt;Das ist das Haus vom Nikolaus.&lt;\/div&gt; Schauen wir uns ein Beispielzitat aus dem Korpus an: &lt;cit&gt; &lt;quote ana=&quot;#formal #s-m #r-n&quot; xml:lang=&quot;deu&quot;&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/quote&gt; &lt;bibl&gt; &lt;title type=&quot;edition&quot;&gt;Jean Paul \u2013 S\u00e4mtliche Briefe digital&lt;\/title&gt; &lt;title type=&quot;letter&quot;&gt;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&lt;\/title&gt; &lt;ref target=&quot;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&quot;\/&gt; &lt;\/bibl&gt; &lt;\/cit&gt; Z. 46-52: Die Inhalte und Metadaten zur zuf\u00e4llig ausgew\u00e4hlten Gru\u00dfformel werden in separaten Variablen gespeichert. Dabei werden die Inhalte mit normalize-space() und local:clean-up() bereinigt, um z.B. Zeilenumbr\u00fcche und ggf. doppelt vorkommende Leerstellen zu entfernen. Der Inhalt der Variable $quote wird in diesem Fall dann &lt;quote&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/quote&gt; sein. Das gilt analog f\u00fcr die anderen Variablen. let $quote := element quote { normalize-space(string-join(local:clean-up($randomcit\/tei:quote))) } let $edition := element edition { normalize-space($randomcit\/\/tei:title[@type='edition']) } let $title := element title { normalize-space($randomcit\/\/tei:title[@type='letter']) } let $language := element language { normalize-space($randomcit\/\/tei:quote\/@xml:lang) } let $url := element url { $randomcit\/\/tei:bibl\/tei:ref\/@target\/data(.) } let $licence := element licence { $randomcit\/\/tei:licence\/@target\/data(.) } Z. 54: Wir erstellen ein neues Element &lt;cit&gt; mit den bereinigten Inhalten aus den Statements zuvor. let $preparedGreeting := element cit {$quote,$edition,$title,$url,$language,$licence} Der Inhalt von $preparedGreeting sollte dann mit dem Beispiel oben wie folgt aussehen: &lt;cit&gt; &lt;quote&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/quote&gt; &lt;edition&gt;Jean Paul \u2013 S\u00e4mtliche Briefe digital&lt;\/edition&gt; &lt;title&gt;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&lt;\/title&gt; &lt;url&gt;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&lt;\/url&gt; &lt;language&gt;deu&lt;\/language&gt; &lt;licence&gt;&lt;\/licence&gt; &lt;\/cit&gt; Z. 57-63: Hier werden die JSON-Serialisierungsparameter angegeben. D.h., hier wird bestimmt, wie der JSON-Output am Ende aussehen soll. let $jsonSerializationParams := &lt;output:serialization-parameters xmlns:output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;&gt; &lt;output:method value=&quot;json&quot;\/&gt; &lt;output:media-type value=&quot;application\/json&quot;\/&gt; &lt;output:json-ignore-whitespace-text-nodes value=&quot;yes&quot;\/&gt; &lt;\/output:serialization-parameters&gt; Z. 66-67: Die berenigten XML-Daten in $preparedGreeting werden mit den von uns vorgegebenen JSON-Serialisierungsparametern $jsonSerializationParams nach JSON umgeformt. return serialize($preparedGreeting, $jsonSerializationParams) Das JSON-Ergebnis sieht wie folgt aus: { &quot;quote&quot;:&quot;Mit Verehrung Ihr ergebenster etc.&quot;, &quot;edition&quot;:&quot;Jean Paul \u2013 S\u00e4mtliche Briefe digital&quot;, &quot;title&quot;:&quot;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&quot;, &quot;url&quot;:&quot;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&quot;, &quot;language&quot;:&quot;deu&quot;, &quot;licence&quot;:null } Code xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; declare namespace output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;; (: Serialisierung nach JSON als Ergebnisziel angeben :) declare option exist:serialize &quot;media-type=application\/json&quot;; (: Helferfunktion um Datenstrukturen zu bereinigen :) declare function local:clean-up($nodes as node()*) as xs:string* { for $node in $nodes return typeswitch($node) case element(tei:lb)|element(tei:abbr)|element(tei:reg)|element(tei:note) return () case element() return local:clean-up($node\/node()) case text() return $node default return local:clean-up($node\/node()) }; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; let $greetings := collection($data)\/\/tei:cit (: W\u00e4hle eine zuf\u00e4llige Position aus der Ergebnisliste :) let $random := util:random(count($greetings)) (: Stelle sicher, dass auch wirklich nur ein Ergebnis ausgew\u00e4hlt wurde :) let $cleanRandom := if ($random &gt;= 1) then $random else 1 (: Hole die Gru\u00dfformel an der Stelle :) let $randomcit := $greetings[position()=$cleanRandom] (: Erstelle Variablen f\u00fcr die Inhalte und Metdaten zu einer Gru\u00dfformel :) let $quote := element quote { normalize-space(string-join(local:clean-up($randomcit\/tei:quote))) } let $edition := element edition { normalize-space($randomcit\/\/tei:title[@type='edition']) } let $title := element title { normalize-space($randomcit\/\/tei:title[@type='letter']) } let $language := element language { normalize-space($randomcit\/\/tei:quote\/@xml:lang) } let $url := element url { $randomcit\/\/tei:bibl\/tei:ref\/@target\/data(.) } let $licence := element licence { $randomcit\/\/tei:licence\/@target\/data(.) } let $preparedGreeting := element cit {$quote,$edition,$title,$url,$language,$licence} (: Bestimmte wie die JSON-Serializierung aussehen soll :) let $jsonSerializationParams := &lt;output:serialization-parameters xmlns:output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;&gt; &lt;output:method value=&quot;json&quot;\/&gt; &lt;output:media-type value=&quot;application\/json&quot;\/&gt; &lt;output:json-ignore-whitespace-text-nodes value=&quot;yes&quot;\/&gt; &lt;\/output:serialization-parameters&gt; (: Serialisiere das zuf\u00e4llige XML-cit-Element nach JSON :) return serialize($preparedGreeting, $jsonSerializationParams)","tags":"","url":"XML_zu_JSON_in_eXist-db\/XML_zu_JSON.html"},{"title":"Abfragen mit Filtern","text":"Abfragen mit Filtern Neuerungen im Code URL-Parameter Einzelner Filter - Briefe von Frauen Mehrere Filter - Briefe von Frauen an Frauen (oder neutral) Erl\u00e4uterungen Code Abfragen mit Filtern In diesem Abschnitt wird die Erkl\u00e4rung zur Datei abfrage.xql erweitert. Es wird gezeigt, wie Daten aus dem quoteSalute nach bestimmten Eigenschaften gefiltert werden k\u00f6nnen, sodass z.B. nur Gru\u00dfformeln von Frauen als Absender ausgew\u00e4hlt werden. Neuerungen im Code \u00d6ffnen Sie die Datei abfrage-tutorial-04.xql in eXide. Schauen Sie sich Code und Kommentare an. F\u00fchren Sie den Code aus. Lassen Sie sich das Ergebnis in eXide oder im Browser anzeigen. Was hat sich im Vergleich zu abfrage-tutorial-03.xql ge\u00e4ndert? Wenn Sie den Code mit eXide ausf\u00fchren, sollte sich im Ergebnis nichts sichtbares ge\u00e4ndert haben. Sie k\u00f6nnen jedoch URL-Parameter angeben, um Daten zu filtern. URL-Parameter \u00dcberfliegen Sie kurz die Dokumentation von quoteSalute. Einzelner Filter - Briefe von Frauen Sie k\u00f6nnen \u00fcber die Browser-URL Parameter (nutzerspezifizierte Werte) an das quoteSalute-Back-End \u00fcbergeben. Das grundlegende Prinzip ist folgenderma\u00dfen: [URL]?parameter=wert. Mit dem ? wird angezeigt, dass Parameter \u00fcbergeben werden sollen. \u00d6ffnen Sie folgende URL in einem neuen Browser-Tab: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql Sie sollten eine Gru\u00dfformel als JSON erhalten. Erweitern Sie die URL mit ?sender=s-f. (s f\u00fcr &quot;sender&quot; und f f\u00fcr &quot;female&quot;) Ihre URL sollte jetzt http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f lauten. Im title-Feld sollten Sie nachvollziehen k\u00f6nnen, dass nur noch Gru\u00dfformeln von Briefen angezeigt werden, deren Verfasser Frauen waren. Laden Sie den Tab mit F5 neu, um sich eine andere zuf\u00e4llige Gru\u00dfformel anzeigen zu lassen. Mehrere Filter - Briefe von Frauen an Frauen (oder neutral) Sie k\u00f6nnen auch mehrere Parameter \u00fcber die Browser-URL \u00fcbergeben. Das grundlegende Prinzip ist folgenderma\u00dfen [URL]?parameter1=wert1&amp;parameter2=wert2. Mit dem &amp; werden Parameterpaare getrennt. \u00d6ffnen Sie folgende URL in einem neuen Browser-Tab: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f Sie sollten eine Gru\u00dfformel als JSON erhalten. Erweitern Sie die URL mit &amp;receiver=r-fXr-n. Ihre URL sollte jetzt http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f&amp;receiver=r-fXr-n Anhand der Daten sollten Sie nachvollziehen k\u00f6nnen, dass nur noch Gru\u00dfformeln von Briefen angezeigt werden, deren Verfasser Frauen waren und deren Empf\u00e4nger entweder auch Frauen waren bzw. so formuliert sind, dass sich das Geschlecht des Empf\u00e4ngers nicht bestimmen l\u00e4sst. Laden Sie den Tab mit F5 neu, um sich eine andere zuf\u00e4llige Gru\u00dfformel anzeigen zu lassen. Erl\u00e4uterungen Z. 12-15: Wir teilen der eXist-db mit, dass die Werte von URL-Parametern in Variablen gespeichert werden sollen, falls diese vorkommen. Zum Beispiel wird in $sender der Wert s-f gespeichert, wenn die Anfrage von der URL http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?sender=s-f kommt. Folgende URL-Parameter werden akzeptiert: type - H\u00f6flichkeitsstufe sender - Geschlecht der absendenden Person receiver - Geschlecht der empfangenden Person language - Sprache, in welcher die Gru\u00dfformel verfasst wurde declare variable $type := request:get-parameter('type', ()); declare variable $sender := request:get-parameter('sender', ()); declare variable $receiver := request:get-parameter('receiver', ()); declare variable $language := request:get-parameter('language', ()); Z. 39-76: Hier werden die URL-Parameterwerte f\u00fcr eine Datenbankabfrage aufbereitet, sodass der quoteSalute-Korpus entsprechend gefiltert werden kann. In dem Code-Schnipsel werden nur type, sender und receiver aufbereitet. Der langauge-Filter ist die n\u00e4chste Challenge. In Code-Bl\u00f6cken zu $type-contains, $sender-contains und $receiver-contains werden Mehrfachnennungen der URL-Parameter aufbereitet. Z.B. wird aus dem URL-Parameter ?receiver=r-fXr-n die XQuery-Schnipsel contains(.\/\/@ana, &quot;#r-f&quot;) und contains(.\/\/@ana, &quot;#r-n&quot;). In den Code-Bl\u00f6cken zu $filter-type, $filter-sender und $filter-receiver werden diese XQuery-Schnipsel dann zu einer Filter-Datenbankanfrage zusammengef\u00fcgt. Z.B. entsteht dann folgender Wertschnipsel: contains(.\/\/@ana, &quot;#r-f&quot;) or contains(.\/\/@ana, &quot;#r-n&quot;). Also liefere nur Gru\u00dfformeln zur\u00fcck, welche im @ana-Attribut die Werte #r-f oder #r-n enthalten. (: START - H\u00f6flichkeitsfilter vorbereiten :) let $type-contains := for $item in tokenize($type, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-type := if (count($type) &gt;= 1) then let $containQuery := string-join($type-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - H\u00f6flichkeitsfilter vorbereiten :) (: START - Absenderfilter vorbereiten :) let $sender-contains := for $item in tokenize($sender, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-sender := if (count($sender) &gt;= 1) then let $containQuery := string-join($sender-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Absenderfilder vorbereiten :) (: START - Empf\u00e4ngerfilter vorbereiten :) let $receiver-contains := for $item in tokenize($receiver, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-receiver := if (count($receiver) &gt;= 1) then let $containQuery := string-join($receiver-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Empf\u00e4ngerfilter vorberiten :) Z. 78: Bereite eine Abfrage (engl. query) vor, indem die bisher bekannte Anfrage collection($data)\/\/tei:cit mit den Filtern erweitert wird. Die ||-Zeichen bedeuten, dass die Werte der dahinterliegenden Variablen und Ausdr\u00fccke an die Abfrage rangef\u00fcgt werden sollen. let $query := ('collection($data)\/\/tei:cit'||$filter-type||$filter-sender||$filter-receiver) Z. 79: Nun holen wir eine Kollektion an Gru\u00dfformeln, auf die die Filter passen. let $greetings := util:eval($query) Der Rest der Datei ist wie bisher und folgt derselben Logik. Code xquery version &quot;3.0&quot;; (: Deklaration von Namensr\u00e4umen. Wichtig f\u00fcr die Arbeit mit TEI-XML-Daten :) declare namespace tei=&quot;http:\/\/www.tei-c.org\/ns\/1.0&quot;; declare namespace output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;; (: Serialisierung nach JSON als Ergebnisziel angeben :) declare option exist:serialize &quot;media-type=application\/json&quot;; (: Request-Parameter entgegenennehmen. Wenn von einer Webseite eine Anfrage kommt, : k\u00f6nnen nutzerdefinierte Angaben mit \u00fcberreicht werden. :) declare variable $type := request:get-parameter('type', ()); declare variable $sender := request:get-parameter('sender', ()); declare variable $receiver := request:get-parameter('receiver', ()); declare variable $language := request:get-parameter('language', ()); (: Helferfunktion um Datenstrukturen zu bereinigen :) declare function local:clean-up($nodes as node()*) as xs:string* { for $node in $nodes return typeswitch($node) case element(tei:lb)|element(tei:abbr)|element(tei:reg)|element(tei:note) return () case element() return local:clean-up($node\/node()) case text() return $node default return local:clean-up($node\/node()) }; (: Variable zum Speichern des Daten-Verzeichnispfads :) let $data := &quot;\/db\/apps\/quotesalute\/data&quot; (: START - H\u00f6flichkeitsfilter vorbereiten :) let $type-contains := for $item in tokenize($type, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-type := if (count($type) &gt;= 1) then let $containQuery := string-join($type-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - H\u00f6flichkeitsfilter vorbereiten :) (: START - Absenderfilter vorbereiten :) let $sender-contains := for $item in tokenize($sender, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-sender := if (count($sender) &gt;= 1) then let $containQuery := string-join($sender-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Absenderfilder vorbereiten :) (: START - Empf\u00e4ngerfilter vorbereiten :) let $receiver-contains := for $item in tokenize($receiver, 'X') let $contain := concat(&quot;#&quot;, $item) return concat('contains(.\/\/@ana, &quot;', $contain, '&quot;)') let $filter-receiver := if (count($receiver) &gt;= 1) then let $containQuery := string-join($receiver-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Empf\u00e4ngerfilter vorberiten :) let $query := ('collection($data)\/\/tei:cit'||$filter-type||$filter-sender||$filter-receiver) let $greetings := util:eval($query) (: W\u00e4hle eine zuf\u00e4llige Position aus der Ergebnisliste :) let $random := util:random(count($greetings)) (: Stelle sicher, dass auch wirklich nur ein Ergebnis ausgew\u00e4hlt wurde :) let $cleanRandom := if ($random &gt;= 1) then $random else 1 (: Hole die Gru\u00dfformel an der Stelle :) let $randomcit := $greetings[position()=$cleanRandom] (: Erstelle Variablen f\u00fcr die Inhalte und Metdaten zu einer Gru\u00dfformel :) let $quote := element quote { normalize-space(string-join(local:clean-up($randomcit\/tei:quote))) } let $edition := element edition { normalize-space($randomcit\/\/tei:title[@type='edition']) } let $title := element title { normalize-space($randomcit\/\/tei:title[@type='letter']) } let $language := element language { normalize-space($randomcit\/\/tei:quote\/@xml:lang) } let $url := element url { $randomcit\/\/tei:bibl\/tei:ref\/@target\/data(.) } let $licence := element licence { $randomcit\/\/tei:licence\/@target\/data(.) } let $preparedGreeting := element cit {$quote,$edition,$title,$url,$language,$licence} (: Bestimmte wie die JSON-Serializierung aussehen soll :) let $jsonSerializationParams := &lt;output:serialization-parameters xmlns:output=&quot;http:\/\/www.w3.org\/2010\/xslt-xquery-serialization&quot;&gt; &lt;output:method value=&quot;json&quot;\/&gt; &lt;output:media-type value=&quot;application\/json&quot;\/&gt; &lt;output:json-ignore-whitespace-text-nodes value=&quot;yes&quot;\/&gt; &lt;\/output:serialization-parameters&gt; (: Serialisiere das zuf\u00e4llige XML-cit-Element nach JSON :) return serialize($preparedGreeting, $jsonSerializationParams)","tags":"","url":"XML_zu_JSON_in_eXist-db\/Abfragen_mit_Filtern.html"},{"title":"Challenge 2 - Ein neuer Filter","text":"Challenge 2: Ein neuer Filter Aufgabe L\u00f6sungsans\u00e4tze Challenge 2: Ein neuer Filter Im Abschnitt zuvor wurden Filter zu H\u00f6flichkeit, Sender und Empf\u00e4nger eingerichtet. In dieser Challenge soll ein Sprach-Filter hinzugef\u00fcgt werden. Aufgabe Erweitern Sie die Datei abfrage-challenge-02.xql. F\u00fcgen Sie einen Sprach-Filter hinzu. Orientieren Sie sich dabei an die bisherigen Filter. \u00dcberpr\u00fcfen Sie, ob Ihr Code funktioniert, indem Sie folgende URL im Browser aufrufen: http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-tutorial-04.xql?language=eng. Wenn Sie nach mehrmaligem Neuladen der Seite nur englische Gru\u00dfformeln angezeigt bekommen, ist ihr Code-Richtig. L\u00f6sungsans\u00e4tze In der Variable $language wird der Sprachwert gespeichert. Dieser kann leer sein, oder z.B. deu, eng oder ita sein. F\u00fchren Sie analog zu den bisherigen Filter-Schritten die Variablen $language-contains und $filter-langauge ein. Erweitern Sie die $query-Variable Ergebnis im Browser \u00fcberpr\u00fcfen.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_2_-_Ein_neuer_Filter.html"},{"title":"Challenge 2 - L\u00f6sung","text":"Challenge 2: L\u00f6sung Erl\u00e4uterung Challenge 2: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 2. Erl\u00e4uterung Analog zu den anderen Filtern wurde der Sprach-Parameter f\u00fcr eine sp\u00e4tere Datenbankabfrage aufbereitet: (: START - Sprachfilter vorbereiten :) let $language-contains := for $item in tokenize($language, 'X') return concat('contains(.\/\/@xml:lang, &quot;', $item, '&quot;)') let $filter-language := if (count($language) &gt;= 1) then let $containQuery := string-join($language-contains, ' or ') return concat('[', $containQuery, ']') else () (: ENDE - Sprachfilter vorbereiten :) Anschlie\u00dfend wurde die $query-Datenbankabfragevariable erweitert. let $query := ('collection($data)\/\/tei:cit'||$filter-type||$filter-sender||$filter-receiver||$filter-language) Ruft man nun http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-challenge-02-solution.xql?language=eng auf, erscheinen nur Gru\u00dfformeln auf Englisch.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Challenge_2_-_L\u00f6sung.html"},{"title":"Zusammenfassung","text":"Zusammenfassung Zusammenfassung In diesem Kapitel haben Sie gelernt, wie man in eXist-db eXide bedient, den quoteSalute-XML-Korpus mit TEI abfragt, zuf\u00e4llige Gru\u00dfformeln extrahiert, XML zu JSON transformiert und Datenbankabfragen mit Filtern versieht. Sie haben Ihr Wissen getestet und folgende Challenges absolviert: Challenge 1: Eine Gru\u00dfformel abrufen Challenge 2: Ein neuer Filter Im folgenden Kapitel werden die ersten Schritte mit VueJS erkl\u00e4rt, sodass im finalen Kapitel die Verbindung von VueJS und eXist-db vollzogen werden kann. Vorerst m\u00fcssen Sie keine weiteren \u00c4nderungen mit eXide vornehmen.","tags":"","url":"XML_zu_JSON_in_eXist-db\/Zusammenfassung.html"},{"title":"\u00dcbersicht","text":"\u00dcbersicht \u00dcbersicht In diesem Kapitel werden die Grundz\u00fcge von VueJS vorgestellt. Zuerst wird das technische Setup besprochen. F\u00fcr dieses Kapitel ben\u00f6tigen Sie grundlegendes Wissen in der Webprogrammierung mit HTML und JavaScript (kurz JS). Sie werden lernen, wie man VueJS in ein HTML-Dokument einbindet, Daten und Templates in einer VueJS-Instanz verwaltet (model binding), Templates mit if-Konditionen und for-Schleifen manipuliert, VueJS-Instanz-interne Funktionen und mit On-Click-Events interaktiv gestaltet, sowie sog. Computed Properties, d.h. sich stetig aktualisierende Variablen, anwendet. Die Code-Beispiele in diesem Kapitel sind etwas vom quoteSalute-Inhalt losgel\u00f6st. Im folgenden und finalen Kapitel werden dann eXist-db und VueJS miteinander verbunden, um das quoteSalute-Front-End zu realisieren.","tags":"","url":"Erste_Schritte_mit_VueJS\/\u00dcbersicht.html"},{"title":"Vorbereitung f\u00fcr VueJS","text":"Vorbereitung f\u00fcr VueJS Beispieldateien Software Firefox Google Chrome Vorbereitung f\u00fcr VueJS Beispieldateien Wir haben Code-Skelette zum Nachvollziehen vorbereitet. Laden Sie folgende Datei herunter und entpacken Sie das ZIP-Archiv auf Ihrem Rechner. Alle Beispiele in diesem Kapitel beziehen sich auf Dateien aus diesem Archiv. vue-examples.zip Die Abh\u00e4ngigkeiten aus den Code-Beispielen werden mitgeliefert. S\u00e4mtlicher JavaScript-Code wird in einem &lt;script&gt;-Block am Ende des &lt;body&gt;-Tags verwaltet, sodass HTML und JavaScript f\u00fcr dieses Tutorial eine geschlossene Einheit bilden. Software Ein moderner Browser, z.B. Mozilla Firefox oder Google Chrome (nicht Internet Explorer!) Ein Code-Editor, z.B. Visual Studio Code, Atom oder Notepad++ Firefox Mit Firefox sollte alles problemlos funktionieren. Optional: Vue.js devtools Google Chrome Sollten Sie Google Chrome (oder Chromium) verwenden, installieren Sie bitte folgende Erweiterung: Web Server for Chrome Wenn Sie JavaScript in HTML-Dateien benutzen m\u00f6chten, die auf Ihrer lokalen Festplatte liegen, blockiert Chrome aus Sicherheitsgr\u00fcnden dessen ausf\u00fchrung. Mit dieser Erweiterung schaffen Sie lokal einen &quot;Mini-Server&quot; f\u00fcr ausgew\u00e4hlte Dateien, um JavaScript lokal im Browser auszuf\u00fchren. Optional: Vue.js devtools","tags":"","url":"Erste_Schritte_mit_VueJS\/Vorbereitung_f\u00fcr_VueJS.html"},{"title":"VueJS benutzen","text":"VueJS benutzen Grundlagen VueJS im HTML-Dokument Code VueJS benutzen In diesem Abschnitt wird kurz beschrieben, was VueJS ist und wie es benutzt werden kann. Zugeh\u00f6rige Beispieldatei: 02_VueJS_benutzen.html Grundlagen VueJS ist eine JavaScript-Software-Bibliothek, welche sich mit anderen Bibliotheken wie React oder AngularJS vergleichen l\u00e4sst. Das grundlegenste Ziel von VueJS ist es, Webseiten reaktiv zu gestalten. Die HTML-Daten werden dabei auf dem Rechner des Nutzers on-the-fly berechnet. Dabei interagieren das Datenmodell und die VueJS-DOM (VueJS-HTML-Templates) miteinander. \u00c4ndert sich ein Wert im Datenmodell, \u00e4ndern sich auch alle Anzeigen, wo dieser Wert referenziert ist. VueJS im HTML-Dokument Um VueJS im eigenen JavaScript-Code nutzen zu k\u00f6nnen, muss es im HTML-Dokument importiert werden. Derzeit ist es g\u00e4ngig JavaScript nicht im &lt;head&gt;-Element, sondern am Ende des &lt;body&gt;-Tags zu importieren. Im body-Bereich legen wir ein div-Element mit der ID root an. Dieses soll als Ziel-Element f\u00fcr unsere Vue-Instanz dienen. &lt;div id=&quot;root&quot;&gt; &lt;!-- Hier kann VueJS zugreifen--&gt; &lt;\/div&gt; Wir laden die VueJS-Bibliothek und erstellen eine neue Vue-Instanz. \u00dcber den el-Parameter teilen wir mit, auf welches Element sich die Vue-Instanz beschr\u00e4nken soll. In diesem Fall das Element mit der ID &quot;root&quot;, also #root. const vue = new Vue({ el: '#root' }); Code Zugeh\u00f6rige Beispieldatei: 02_VueJS_benutzen.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: VueJS einbinden&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;VueJS einbinden&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- Hier kann VueJS zugreifen--&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root' }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/VueJS_benutzen.html"},{"title":"Data und Templates","text":"Data und Templates Data Templates Aufgabe Code Data und Templates In diesem Abschnitt wird beschrieben, wie man das Datenmodell in einer VueJS-Instanz verwaltet und im HTML-Code nutzbar macht. Zugeh\u00f6rige Beispieldatei: 03_Data_und_Templates.html Data Die Vue-Instanz \u00e4hnelt vom Aufbau einem JSON-Objekt. Das data-Element verwaltet das interne Datenmodell der Vue-Instanz. Nach dem Key-Value-Prinzip k\u00f6nnen hier neue Variablen angelegt werden. Der data-Variable name wird der Wert Alexander von Humboldt zugeordnet. Der data-Variable shoppingList eine Liste mit den Werten Bananen, Brot und Schokolade. const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ] } }); Zwar sind die Variablen nun vorhanden, jedoch noch nicht angezeigt. Templates Auf die Variablen kann im Vue-Bereich des HTML-Codes nun zugegriffen werden. Mit {{ variable }} wird der Wert einer Variable ausgegeben. {{ name }} wird also automatisch mit Alexander von Humboldt ersetzt. Man kann auch \u00fcber Listen iterieren. F\u00fcr jeden Eintrag item in der Einkaufliste shoppingList erstelle ein Listenelement &lt;li&gt; und trage dort den Wert von item ein. Die v-Direktiven werden wie normale HTML- bzw. XML-Attribute behandelt, d.h. die Werte sind von &quot; &quot; umschlossen. &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; Der gesamte Code-Schnipsel sieht also wie folgt aus. &lt;div id=&quot;root&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; &lt;\/ul&gt; &lt;\/div&gt; &lt;\/div&gt; Wenn Sie die Datei mit Ihrem Browser \u00f6ffnen, sollte folgender Output zu sehen sein. Mein Name ist Alexander von Humboldt. Meine Einkaufsliste lautet: Bananen Brot Schokolade Aufgabe \u00d6ffnen Sie die Datei 03_Data_und_Templates.html mit ihrem Browser (rechtsklick -&gt; \u00d6ffnen mit...) \u00d6ffnen Sie die Datei 03_Data_und_Templates.html mit einem Text-Editor. \u00c4ndern Sie die Werte im data-Element in der Vue-Instanz. F\u00fcgen Sie weitere Werte zur Einkaufsliste hinzu. Speichern Sie das HTML-Dokument. Laden Sie die Seite in Ihrem Browser neu. Haben sich die Werte ge\u00e4ndert? Code Zugeh\u00f6rige Beispieldatei: 03_Data_und_Templates.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: Data und Templates&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;Data und Templates&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; &lt;\/ul&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ] } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/Data_und_Templates.html"},{"title":"Challenge 1 - Anzeige mit Bedingungen","text":"Challenge 1: Anzeige mit Bedingungen Aufgabe L\u00f6sungsstrategien Challenge 1: Anzeige mit Bedingungen Aufgabe Versuchen Sie den VueJS-HTML-Code so anzupassen, dass nur Gegenst\u00e4nde von der Einkaufsliste angezeigt werden, wenn sie mit 'B' beginnen. Wenn der Gegenstand nicht mit 'B' beginnt, soll der Eintrag mit Geheim! ersetzt werden. Zugeh\u00f6rige Beispieldatei: 04_Challenge_1.html L\u00f6sungsstrategien Mit dem v-if-Attribut kann eine Bedingung formuliert werden. Eine Alternative kann mit dem v-else-Attribut angegeben werden. v-if kann im selben Element wie v-for vorkommen. Siehe auch: Vue: Conditional Rendering (engl.) Zum Beispiel: &lt;!-- angenommen: anzahl = 3 --&gt; &lt;div&gt; Ich m\u00f6chte {{ anzahl }} &lt;span v-if=&quot;anzahl &gt; 1&quot;&gt;B\u00fccher&lt;\/span&gt; &lt;span v-else&gt;Buch&lt;\/span&gt; kaufen &lt;\/span Mit der JavaScript-Funktion startsWith k\u00f6nnen Sie \u00fcberpr\u00fcfen, ob eine Zeichenkette mit einem bestimmten Buchstaben beginnt. Wenden Sie diese Funktion auf item an. const name = 'Alexander von Humboldt'; name.startsWith('A') \/\/ true","tags":"","url":"Erste_Schritte_mit_VueJS\/Challenge_1_-_Anzeige_mit_Bedingungen.html"},{"title":"Challenge 1 - L\u00f6sung","text":"Challenge 1: L\u00f6sung Erl\u00e4uterung Challenge 1: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 1: Anzeige mit Bedingungen. &lt;div id=&quot;root&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot; v-if=&quot;item.startsWith('B')&quot;&gt;{{ item }}&lt;\/li&gt; &lt;li v-else&gt;Geheim!&lt;\/li&gt; &lt;\/ul&gt; &lt;\/div&gt; &lt;\/div&gt; Erl\u00e4uterung Mit dem Vue-Attribut v-if=&quot;item.startsWith('B') wird gepr\u00fcft, ob der anzuzeigende Gegenstand in der Einkaufsliste mit 'B' beginnt. Diese Pr\u00fcfung wird f\u00fcr jeden Eintrag in der Einkaufsliste vorgenommen. Falls die Pr\u00fcfung fehlschl\u00e4gt, greift die v-else-Direktive.","tags":"","url":"Erste_Schritte_mit_VueJS\/Challenge_1_-_L\u00f6sung.html"},{"title":"Vue Models - Daten eingeben","text":"Vue Models - Daten eingeben Formulare und VueJS Austesten Code Vue Models - Daten eingeben In diesem Abschnitt wird gezeigt, wie man HTML-Formulare ans Vue Datenmodell data anbindet. Zugeh\u00f6rige Beispieldatei: 06_Vue_Models_-_Daten_eingeben.html Formulare und VueJS Im Schritt zu Data und Templates wurde gezeigt, wie man Variablen im data-Bereich von VueJS einrichtet und diese im HTML-Code nachnutzt. Nun soll gezeigt werden, wie man Variablen im data-Bereich \u00fcber HTML-Formulare \u00e4ndern kann. Nutzereingaben erfolgen in &lt;input&gt;-Elementen. Mit dem v-model-Attribut k\u00f6nnen wir eine data-Variable Referenzieren. Dazu legen wir ein neues Formular an und referenzieren die Namensvariable mit dem Attribut v-model=&quot;name&quot;. Immer wenn sich der Wert in dem Input \u00e4ndern, \u00e4ndert sich der Wert der Variable im data-Bereich. &lt;label&gt;Namen eingeben:&lt;\/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; Austesten \u00d6ffnen Sie die Datei 06_Vue_Models_-_Daten_eingeben.html mit einem Browser. Geben Sie einen Namen in das Eingabefeld ein. Beobachten Sie den &quot;Hallo...&quot;-Text. \u00c4ndert er sich, w\u00e4hrend Sie etwas eingeben? Code Zugeh\u00f6rige Beispieldatei: 06_Vue_Models_-_Daten_eingeben.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: Challenge 1 - L\u00f6sung&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;Challenge 1: L\u00f6sung&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;label&gt;Namen eingeben:&lt;\/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot; v-if=&quot;item.startsWith('B')&quot;&gt;{{ item }}&lt;\/li&gt; &lt;li v-else&gt;Geheim!&lt;\/li&gt; &lt;\/ul&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ] } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/Vue_Models_-_Daten_eingeben.html"},{"title":"Vue Methods - Funktionen auf Abruf","text":"Vue Methods - Funktionen auf Abruf Methoden nutzen Ziel Vorgehen Aufgabe Code Vue Methods - Funktionen auf Abruf In diesem Abschnitt wird erkl\u00e4rt, wie man den methods-Bereich einer Vue-Instanz benutzt. Zugeh\u00f6rige Beispieldatei: 07_Vue_Methods_-_Funktionen_auf_Abruf.html Methoden nutzen Im vergangenen Abschnitt wurde gezeigt, wie man das Vue data model in HTML-Formularen manipulierbar macht. Dort wurde die Variable &quot;live&quot; beobachtet und aktualisiert. Hier soll demonstriert werden, die man eine Funktion auf Abruf, z.B. auf einen Button-Klick, einrichtet. Ziel Die Einkaufsliste soll auf einen Button-Klick geleert werden. Vorgehen Wir f\u00fcgen einen Button im HTML-Code hinzu. &lt;button class=&quot;btn btn-primary&quot;&gt;Liste leeren&lt;\/button&gt; Wir erstellen den methods-Bereich in unserer VueJS-Instanz und f\u00fcgen eine neue Funktion emptyList() hinzu. Wird die Funktion emptyList() ausgef\u00fchrt, wird die Einkaufslistenvariable shoppingList geleert, indem die Eintr\u00e4ge durch eine leere Liste ersetzt werden. Innerhalb der Vue-Instanz bezieht sich this auf s\u00e4mtliche Vue-internen Informationen, wie data, methods und computed Properties (siehe hier) const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ] }, methods: { emptyList() { this.shoppingList = []; } } }); Nun f\u00fcgen wir zum neuen Button einen Event-Listener hinzu. Mit der Attribut-Direktive v-on:click k\u00f6nnen wir eine Methode angeben. &lt;button class=&quot;btn btn-primary&quot; v-on:click=&quot;emptyList&quot;&gt;Liste leeren&lt;\/button&gt; Diese Direktive kann auch verk\u00fcrzt werden zu @click. &lt;button class=&quot;btn btn-primary&quot; @click=&quot;emptyList&quot;&gt;Liste leeren&lt;\/button&gt; Aufgabe \u00d6ffnen Sie die Datei 07_Vue_Methods_-_Funktionen_auf_Abruf.html. Klicken Sie auf den &quot;Liste Leeren&quot;-Button. Wird die Liste bei Ihnen gel\u00f6scht? Code Zugeh\u00f6rige Beispieldatei: 07_Vue_Methods_-_Funktionen_auf_Abruf.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: Challenge 1 - L\u00f6sung&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;Challenge 1: L\u00f6sung&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;label&gt;Namen eingeben:&lt;\/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot; v-if=&quot;item.startsWith('B')&quot;&gt;{{ item }}&lt;\/li&gt; &lt;li v-else&gt;Geheim!&lt;\/li&gt; &lt;\/ul&gt; &lt;button class=&quot;btn btn-primary&quot; @click=&quot;emptyList&quot;&gt;Liste leeren&lt;\/button&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ] }, methods: { emptyList() { this.shoppingList = []; } } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/Vue_Methods_-_Funktionen_auf_Abruf.html"},{"title":"Challenge 2 - Liste erweitern","text":"Challenge 2: Liste erweitern Aufgabe L\u00f6sungsans\u00e4tze Besondere Herausforderung Challenge 2: Liste erweitern Im vergangenen Abschnitt wurde gezeigt, wie man Funktionen auf Abruf in einer VueJS-Instanz nutzen kann. Davor wurde gezeigt, wie man Inputs mit dem VueJS Datenmodell koppelt. Zugeh\u00f6rige Beispieldatei: 08_Challenge_2.html Aufgabe Kreieren Sie eine M\u00f6glichkeit neue Dinge zur Einkaufsliste hinzuzuf\u00fcgen. Folgen Sie dabei den L\u00f6sungsans\u00e4tzen und orientieren Sie sich am bereits existierenden Code. L\u00f6sungsans\u00e4tze Die zu bearbeitenden Stellen im Code sind mit \/\/ TODO oder &lt;!-- TODO --&gt; markiert. Schaffen eine neue data-Variable mit dem Namen newItem. Der Wert sollte leer sein (''). Vergessen Sie nicht Kommata zu setzen. Erstellen Sie im Methods-Bereich eine neue Funktion addItem(). Wenn diese ausgef\u00fchrt wird, soll der aktuelle Wert von newItem in die shoppingList hinzugef\u00fcgt werden. Nutzen Sie dazu die push()-Funktion f\u00fcr Listen (Beispiel siehe unten). Setzen Sie this richtig ein. Erstellen Sie im HTML-Bereich einen neuen Text-Input und binden Sie ihn \u00fcber die v-model-Direktive an die entsprechende Variable. Erstellen Sie einen Neuen Button mit der Aufschrift &quot;Hinzuf\u00fcgen&quot;. Wenn der Button geklickt wird, soll die Funktion addItem ausgef\u00fchrt werden. let listOfAnimals = ['Hund', 'Katze', 'Maus']; const panda = 'Panda'; listOfAnimals.push(panda); \/\/ ['Hund', 'Katze', 'Maus', 'Panda']; Besondere Herausforderung Wenn der &quot;Hinzuf\u00fcgen&quot;-Button geklickt wird, soll der newItem-Wert wieder geleert werden. Stellen Sie sicher, dass keine doppelten Eintr\u00e4ge in die Einkaufsliste aufgenommen werden. Stellen Sie sicher, dass keine leeren Eintr\u00e4ge in die Einkaufsliste aufgenommen werden.","tags":"","url":"Erste_Schritte_mit_VueJS\/Challenge_2_-_Liste_erweitern.html"},{"title":"Challenge 2 - L\u00f6sung","text":"Challenge 2: L\u00f6sung JavaScript HTML Code Challenge 2: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 2: Liste erweitern. JavaScript Im data-Bereich wurde eine neue Variable newItem vergeben. Im methods-Bereich wurde eine neue Funktion addItem() angelegt. Diese wird n\u00e4her erl\u00e4utert. if (this.newItem.length) - Wenn die Zeichenkette vom neuen Eintrag gr\u00f6\u00dfer als 0 ist. if (!this.shoppingList.includes(this.newItem)) - Wenn der Eintrag noch nicht in der Einkaufsliste existiert. this.shoppingList.push(this.newItem) - F\u00fcge den neuen Eintrag der Einkaufsliste hinzu. this.newItem = '' - Setze die Eingabe auf einen leeren String zur\u00fcck. addItem() { if (this.newItem.length &amp;&amp; !this.shoppingList.includes(this.newItem)) { this.shoppingList.push(this.newItem); this.newItem = ''; } Insgesamt k\u00f6nnte der JavaScript-Teil Ihrer Vue-Instanz folgenderma\u00dfen aussehen. const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ], \/\/ TODO - Hier neue Variable anlegen newItem: '', }, methods: { emptyList() { this.shoppingList = []; }, \/\/ TODO - Hier neue Funktion anlegen addItem() { if (this.newItem.length &amp;&amp; !this.shoppingList.includes(this.newItem)) { this.shoppingList.push(this.newItem); this.newItem = ''; } } } }); HTML Folgende Elemente wurden hinzugef\u00fcgt: &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot;&gt; - Neues Text-Formular-Feld, welches via v-model an die newItem-Variable gebunden wurde. &lt;button class=&quot;btn btn-info&quot; @click=&quot;addItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; - Neuer Button. Wenn er geklickt wird, wird die Funktion addItem() ausgef\u00fchrt (s.o.). &lt;div&gt; &lt;label&gt;Neuer Wunsch:&lt;\/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot;&gt; &lt;button class=&quot;btn btn-info&quot; @click=&quot;addItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; &lt;\/div&gt; Code Zugeh\u00f6rige Beispieldatei: 09_Challenge_2_-_Solution.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: Challenge 1 - L\u00f6sung&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;Challenge 2: L\u00f6sung&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;label&gt;Namen eingeben:&lt;\/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; &lt;\/ul&gt; &lt;button class=&quot;btn btn-primary&quot; @click=&quot;emptyList&quot;&gt;Liste leeren&lt;\/button&gt; &lt;!-- TODO: Hier neuen Input und Button anlegen--&gt; &lt;div&gt; &lt;label&gt;Neuer Wunsch:&lt;\/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot;&gt; &lt;button class=&quot;btn btn-info&quot; @click=&quot;addItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ], \/\/ TODO - Hier neue Variable anlegen newItem: '', }, methods: { emptyList() { this.shoppingList = []; }, \/\/ TODO - Hier neue Funktion anlegen addItem() { if (this.newItem.length &amp;&amp; !this.shoppingList.includes(this.newItem)) { this.shoppingList.push(this.newItem); this.newItem = ''; } } } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/Challenge_2_-_L\u00f6sung.html"},{"title":"Computed Properties - Immer auf dem aktuellsten Stand","text":"Computed Properties - Immer auf dem aktuellsten Stand Eingaben validieren computed-Bereich Variablen an Attribute binden Code Computed Properties - Immer auf dem aktuellsten Stand Im Abschnitt zuvor wurde gezeigt, wie Funktionen auf Abruf, z.B. bei einem Button-Klick, aufgerufen werden k\u00f6nnen. Es gibt auch Computed Properties, also live-berechnete Werteigenschaften. Diese kann man als Variablen verstehen, sich im Template-Bereich wie ein Wert verhalten, im JavaScript-Bereich jedoch wie eine Funktion funktionieren. Kernfunktion: \u00c4ndert sich der Wert eines Werts, der in der computed-Funktion referenziert ist, wird diese Funktion neu ausgef\u00fchrt und ein neuer Wert berechnet. Eingaben validieren In der Challenge 2 sollten Eingabem\u00f6glichkeiten f\u00fcr neue Einkaufslisteneintr\u00e4ge geschaffen werden. Wenn die Eingabe jedoch noch leer ist, oder der Einkaufswunsch bereits auf der Liste steht, soll man den Button nicht dr\u00fccken k\u00f6nnen. Weiterhin sollte angezeigt werden computed-Bereich Wir erweitern unsere VueJS-Instanz um den computed-Bereich. Dieser \u00e4hnelt im Aufbau dem methods-Bereich. Dabei legen wir eine computed-property-Funktion isValidNewItem(), welches \u00fcberpr\u00fcfen soll, ob der neuer Eintrag leer oder bereits vorhanden ist. const vue = new Vue({ el: '#root', data: { \/\/ ... }, methods: { \/\/ ... }, computed: { isValidNewItem() { if (this.shoppingList.includes(this.newItem) || this.newItem.length === 0) { return false; } return true; }, } }); Szenario 1: Einkaufsliste: [Brot, Bananen, Schokolade] Neuer Eintrag: (leer) isValidNewItem: false Szenario 2: Einkaufsliste: [Brot, Bananen, Schokolade] Neuer Eintrag: Brot isValidNewItem: false Szenario 3: Einkaufsliste: [Brot, Bananen, Schokolade] Neuer Eintrag: Bier isValidNewItem: true Nun kann isValidNewItem wie eine data-Variable im HTML-Bereich genutzt werden. Variablen an Attribute binden Man kann einen Button deaktivieren, wenn man ihm das disabled-Attribut verleiht. &lt;button disabled&gt;Hinzuf\u00fcgen&lt;\/button&gt; Das disabled-Attribut soll jedoch nur dann aktiviert sein, wenn isValidNewItem nicht true ist. Mit ! k\u00f6nnen true und false Werte umgekehrt werden, also !isValidNewItem. Mit der v-bind-Direktive kann der Status von isValidNewItem an das disabled-Attribut gebunden werden &lt;button v-bind:disabled=&quot;!isValidNewItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; Dieser Ausdruck kann auch verk\u00fcrzt werden: &lt;button :disabled=&quot;!isValidNewItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; Code Zugeh\u00f6rige Beispieldatei: 10_Computed_Properties_-_Immer_auf_dem_aktuellsten_Stand.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: Challenge 1 - L\u00f6sung&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;Challenge 2: L\u00f6sung&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;label&gt;Namen eingeben:&lt;\/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste lautet: &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; &lt;\/ul&gt; &lt;button class=&quot;btn btn-primary&quot; @click=&quot;emptyList&quot;&gt;Liste leeren&lt;\/button&gt; &lt;!-- TODO: Hier neuen Input und Button anlegen--&gt; &lt;div&gt; &lt;label&gt;Neuer Wunsch:&lt;\/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot;&gt; &lt;button class=&quot;btn btn-info&quot; @click=&quot;addItem&quot; v-bind:disabled=&quot;!isValidNewItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ], \/\/ TODO - Hier neue Variable anlegen newItem: '', }, methods: { emptyList() { this.shoppingList = []; }, \/\/ TODO - Hier neue Funktion anlegen addItem() { if (this.newItem.length &amp;&amp; !this.shoppingList.includes(this.newItem)) { this.shoppingList.push(this.newItem); this.newItem = ''; } } }, computed: { isValidNewItem() { if (this.shoppingList.includes(this.newItem)) { return false; } if (this.newItem.length) { return true; } return false; }, } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/Computed_Properties_-_Immer_auf_dem_aktuellsten_Stand.html"},{"title":"Challenge 3 - Mehr Infos mit Computed Properties","text":"Challenge 3: Mehr Infos mit Computed Properties Aufgaben L\u00f6sungsans\u00e4tze Challenge 3: Mehr Infos mit Computed Properties Zugeh\u00f6rige Beispieldatei: 11_Challenge_3.html Aufgaben Lassen Sie eine Information mit dem Text Neuer Eintrag leer oder bereits vorhanden einblenden, wenn isValidNewItem den Status false hat. Erstellen Sie ein neues Element im HTML-Bereich, wo Sie die Anzahl der Eintr\u00e4ge in der Einkaufsliste anzeigen. Folgen Sie dabei den L\u00f6sungsans\u00e4tzen und orientieren Sie sich am bereits existierenden Code. L\u00f6sungsans\u00e4tze Die zu bearbeitenden Stellen im Code sind mit \/\/ TODO oder &lt;!-- TODO --&gt; markiert. Erstellen Sie im HTML-Bereich ein neues &lt;div&gt; oder &lt;span&gt;-Element und nutzen Sie die v-if-Direktive in Verbindung mit isValidNewItem. Mit einem ! vor isValidNewItem k\u00f6nnen Sie die Werte true und false ins Gegenteil verkehren. Erstellen Sie im computed-Bereich eine neue Computed Property numberOfItems. Sie k\u00f6nnen sich die Anzahl aller Eintr\u00e4ge in einer Liste z.B. folgenderma\u00dfen anzeigen lassen: let listOfAnimals = ['Hund', 'Katze', 'Maus']; listOfAnimals.length; \/\/ 3 Erstellen Sie im HTML-Bereich an der markierten Stelle ein neues Element und lassen dort die Anzahl der Listeneintr\u00e4ge anzeigen.","tags":"","url":"Erste_Schritte_mit_VueJS\/Challenge_3_-_Mehr_Infos_mit_Computed_Properties.html"},{"title":"Challenge 3 - L\u00f6sung","text":"Challenge 3: L\u00f6sung JS HTML Code Challenge 3: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 3: Mehr Infos mit Computed Properties. JS Im computed-Bereich wurde eine neue Computed Property numberOfItems angelegt. computed: { isValidNewItem() { if (this.shoppingList.includes(this.newItem) || this.newItem.length === 0) { return false; } return true; }, \/\/ TODO - hier neue Computed Property anlegen numberOfItems() { return this.shoppingList.length; } } HTML Die Anzahl der Einkaufslisteneintr\u00e4ge wird hier gezeigt: Meine Einkaufsliste &lt;span&gt;({{ numberOfItems }}) &lt;\/span&gt;lautet: Die Zusatzinformation, ob ein neuer Eintrag noch leer oder bereits in der Einkaufsvorhanden ist, wurde folgenderma\u00dfen gel\u00f6st. Es folgt dem gleichen Schema wie der Button-Deaktivierung aus dem Abschnitt zu Computed Properties. &lt;div&gt; &lt;label&gt;Neuer Wunsch:&lt;\/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot;&gt; &lt;button class=&quot;btn btn-info&quot; @click=&quot;addItem&quot; v-bind:disabled=&quot;!isValidNewItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; &lt;\/div&gt; &lt;!-- TODO - Hier Info anzeigen, wenn die Eingabe nicht g\u00fcltig ist--&gt; &lt;div v-if=&quot;!isValidNewItem&quot;&gt; Neuer Eintrag leer oder bereits vorhanden &lt;\/div&gt; Code Zugeh\u00f6rige Beispieldatei: 12_Challenge_3_-_Solution.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: Challenge 1 - L\u00f6sung&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;Challenge 2: L\u00f6sung&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;label&gt;Namen eingeben:&lt;\/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;div&gt;Mein Name ist: {{ name }}&lt;\/div&gt; &lt;div&gt; Meine Einkaufsliste &lt;span&gt;({{ numberOfItems }}) &lt;\/span&gt;lautet: &lt;!-- TODO - Hier die Anzahl der Listeneintr\u00e4ge anzeigen lassen --&gt; &lt;ul&gt; &lt;li v-for=&quot;item in shoppingList&quot;&gt;{{ item }}&lt;\/li&gt; &lt;\/ul&gt; &lt;button class=&quot;btn btn-primary&quot; @click=&quot;emptyList&quot;&gt;Liste leeren&lt;\/button&gt; &lt;div&gt; &lt;label&gt;Neuer Wunsch:&lt;\/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot;&gt; &lt;button class=&quot;btn btn-info&quot; @click=&quot;addItem&quot; v-bind:disabled=&quot;!isValidNewItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt; &lt;\/div&gt; &lt;!-- TODO - Hier Info anzeigen, wenn die Eingabe nicht g\u00fcltig ist--&gt; &lt;div v-if=&quot;!isValidNewItem&quot;&gt; Neuer Eintrag leer oder bereits vorhanden &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#root', data: { name: 'Alexander von Humboldt', shoppingList: [ 'Bananen', 'Brot', 'Schokolade' ], newItem: '', }, methods: { emptyList() { this.shoppingList = []; }, addItem() { if (this.newItem.length &amp;&amp; !this.shoppingList.includes(this.newItem)) { this.shoppingList.push(this.newItem); this.newItem = ''; } } }, computed: { isValidNewItem() { if (this.shoppingList.includes(this.newItem) || this.newItem.length === 0) { return false; } return true; }, \/\/ TODO - hier neue Computed Property anlegen numberOfItems() { return this.shoppingList.length; } } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"Erste_Schritte_mit_VueJS\/Challenge_3_-_L\u00f6sung.html"},{"title":"Zusammenfassung","text":"Zusammenfassung Zusammenfassung In diesem Kapitel wurde gezeigt, wie man VueJS in ein HTML-Dokument einbindet, Daten und Templates in einer VueJS-Instanz verwaltet, Templates mit if-Konditionen und Formulareingaben nutzt, VueJS-Instanz-interne Funktionen und mit On-Click-Events interaktiv gestaltet, sowie sog. Computed Properties, d.h. sich stetig aktualisierende Variablen, anwendet. Es gab drei Challenges, um das erlernte Wissen anzuwenden: Challenge 1: Anzeige mit Bedingungen Challenge 2: Liste erweitern Challenge 1: Mehr Infos mit Computed Properties Im folgenden Kapitel werden die Inhalte der ersten beiden Kapitel dann zusammengef\u00fchrt. Die Daten aus der eXist-db werden nach JSON serialisiert und im Front-End \u00fcber VueJS anzeigbar gemacht.","tags":"","url":"Erste_Schritte_mit_VueJS\/Zusammenfassung.html"},{"title":"\u00dcbersicht","text":"\u00dcbersicht \u00dcbersicht In diesem Abschnitt werden Sie lernen, wie man die Datenstruktur von quoteSalute in VueJS nutzbar macht, VueJS an eine eXist-db mit vue-resource anbindet, Filterm\u00f6glichkeiten und Parameter\u00fcbergaben implementiert. Es gibt drei Challenges: Challenge 1: Datenstrukturen und Templates anlegen Challenge 2: Neue Gru\u00dfformel zum Start Challenge 3: Neue Gru\u00dfformel auf Knopfdruck","tags":"","url":"eXist-db_und_VueJS\/\u00dcbersicht.html"},{"title":"Technisches Setup","text":"Technisches Setup Beispieldateien Software Firefox Google Chrome Technisches Setup Beispieldateien Wir haben Code-Skelette zum Nachvollziehen vorbereitet. Laden Sie folgende Datei herunter und entpacken Sie das ZIP-Archiv auf Ihrem Rechner. Alle Beispiele in diesem Kapitel beziehen sich auf Dateien aus diesem Archiv. quoteSalute-examples.zip Die Abh\u00e4ngigkeiten aus den Code-Beispielen werden mitgeliefert. S\u00e4mtlicher JavaScript-Code wird in einem &lt;script&gt;-Block am Ende des &lt;body&gt;-Tags verwaltet, sodass HTML und JavaScript f\u00fcr dieses Tutorial eine geschlossene Einheit bilden. Software Ein moderner Browser, z.B. Mozilla Firefox oder Google Chrome (nicht Internet Explorer!) Ggf. eine Browser-Erweiterung zur Nutzung von CORS-Daten (siehe unten), falls Sie die REST-API von quoteSalute nutzen m\u00f6chten. Ein Code-Editor, z.B. Visual Studio Code, Atom oder Notepad++ Firefox Mit Firefox sollte alles problemlos funktionieren. Optional: Vue.js devtools CORS Everywhere Google Chrome Sollten Sie Google Chrome (oder Chromium) verwenden, installieren Sie bitte folgende Erweiterungen: Web Server for Chrome Wenn Sie JavaScript in HTML-Dateien benutzen m\u00f6chten, die auf Ihrer lokalen Festplatte liegen, blockiert Chrome aus Sicherheitsgr\u00fcnden dessen ausf\u00fchrung. Mit dieser Erweiterung schaffen Sie lokal einen &quot;Mini-Server&quot; f\u00fcr ausgew\u00e4hlte Dateien, um JavaScript lokal im Browser auszuf\u00fchren. Optional: Allow CORS Vue.js devtools","tags":"","url":"eXist-db_und_VueJS\/Technisches_Setup.html"},{"title":"quoteSalute Datenstruktur","text":"quoteSalute Datenstruktur XML-Daten Ergebnisse im Browser Lokale eXist-db Instanz quoteSalute (live) JSON-Daten quoteSalute Datenstruktur Dieser Abschnitt wiederholt einige Schritte und Inhalte, die Bereits im Kapitel zur Nutzung von eXist-db behandelt wurden. XML-Daten Eine Gru\u00dfformel im quoteSalute ist in der eXist-db folgenderma\u00dfen hinterlegt: &lt;cit&gt; &lt;quote&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/quote&gt; &lt;edition&gt;Jean Paul \u2013 S\u00e4mtliche Briefe digital&lt;\/edition&gt; &lt;title&gt;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&lt;\/title&gt; &lt;url&gt;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&lt;\/url&gt; &lt;language&gt;deu&lt;\/language&gt; &lt;licence&gt;&lt;\/licence&gt; &lt;\/cit&gt; Ergebnisse im Browser Sie k\u00f6nnen sich ein zuf\u00e4lliges Zitat aus der eXist-db App von quoteSalute direkt \u00fcber ihren Browser im Rohformat anzeigen lassen. Lokale eXist-db Instanz Eigene Datei abfrage-challenge-02.xql - http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage-challenge-02.xql Vorgefertigte Datei abfrage.xql - http:\/\/localhost:8080\/exist\/apps\/quotesalute\/abfrage.xql quoteSalute (live) Von quoteSalute bereitgestellte Schnittstelle - https:\/\/correspsearch.net\/quotesalute\/abfrage.xql JSON-Daten Das Ergebnis wird letztendlich von der eXist-db App zu JSON serialisiert und zur\u00fcckgeliefert. { &quot;quote&quot;:&quot;Mit Verehrung Ihr ergebenster etc.&quot;, &quot;edition&quot;:&quot;Jean Paul \u2013 S\u00e4mtliche Briefe digital&quot;, &quot;title&quot;:&quot;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&quot;, &quot;url&quot;:&quot;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&quot;, &quot;language&quot;:&quot;deu&quot;, &quot;licence&quot;:null } Diese Gru\u00dfformel wird fortan als Startbeispiel genutzt.","tags":"","url":"eXist-db_und_VueJS\/quoteSalute_Datenstruktur.html"},{"title":"quoteSalute Basisvorlage","text":"quoteSalute Basisvorlage JavaScript HTML Code quoteSalute Basisvorlage In diesem Abschnitt wird der Grundaufbau der quoteSalute VueJS-App vorgestellt. Zugeh\u00f6rige Beispieldatei: 03_quoteSalute_Basisvorlage.html JavaScript Im JavaScript-Abschnitt wurde eine neue VueJS-Instanz initialisiert. Diese greift auf den Bereich im HTML-Code mit der ID #quoteSalute zu. &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#quoteSalute', data: { \/\/ data noch leer } }); &lt;\/script&gt; HTML Das Gru\u00dfformelbeispiel aus dem vorigen Abschnitt wird vorerst hart in den HTML-Code eingetragen. Vergleichen Sie es mit dem XML- und JSON-Code aus dem vorigen Abschnitt. &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Jean Paul \u2013 S\u00e4mtliche Briefe digital&lt;\/h5&gt; &lt;h6 class=&quot;card-subtitle mb-2 text-muted&quot;&gt;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&lt;\/h6&gt; &lt;p class=&quot;card-text&quot;&gt;&lt;em&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/em&gt;&lt;\/p&gt; &lt;a href=&quot;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&quot; class=&quot;card-link&quot; target=&quot;_blank&quot;&gt;Zum Originalbrief&lt;\/a&gt; &lt;\/div&gt; &lt;\/div&gt; Code Zugeh\u00f6rige Beispieldatei: 03_quoteSalute_Basisvorlage.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: quoteSalute&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;quoteSalute&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;quoteSalute&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Jean Paul \u2013 S\u00e4mtliche Briefe digital&lt;\/h5&gt; &lt;h6 class=&quot;card-subtitle mb-2 text-muted&quot;&gt;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&lt;\/h6&gt; &lt;p class=&quot;card-text&quot;&gt;&lt;em&gt;Mit Verehrung Ihr ergebenster etc.&lt;\/em&gt;&lt;\/p&gt; &lt;a href=&quot;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&quot; class=&quot;card-link&quot; target=&quot;_blank&quot;&gt;Zum Originalbrief&lt;\/a&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#quoteSalute', data: { \/\/ data noch leer } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"eXist-db_und_VueJS\/quoteSalute_Basisvorlage.html"},{"title":"Challenge 1 - Datenstruktur und Templates anlegen","text":"Challenge 1: Datenstruktur und Templates anlegen Aufgabe L\u00f6sungsans\u00e4tze Challenge 1: Datenstruktur und Templates anlegen Im vorherigen Kapitel haben Sie gelernt, wie man Variablen mit VueJS verwaltet und anzeigt. Zugeh\u00f6rige Beispieldatei: 04_Challenge_1_-_Datenstruktur_und_Templates_anlegen.html Aufgabe Erstellen Sie das Datenmodell der Vue-Instanz und lassen Sie die Daten im HTML-Code an den passenden Stellen anzeigen. Nehmen Sie zuerst folgende JSON-Gru\u00dfformel als Orientierungspunkt. { &quot;quote&quot;:&quot;Mit Verehrung Ihr ergebenster etc.&quot;, &quot;edition&quot;:&quot;Jean Paul \u2013 S\u00e4mtliche Briefe digital&quot;, &quot;title&quot;:&quot;An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.&quot;, &quot;url&quot;:&quot;https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612&quot;, &quot;language&quot;:&quot;deu&quot;, &quot;licence&quot;:null } L\u00f6sungsans\u00e4tze \u00d6ffnen Sie die Datei 04_Challenge_1.html sowohl mit einem Editor und Browser. Wenn das Ergebnis im Browser wie vor den \u00c4nderungen aussieht, scheint Ihre L\u00f6sung richtig zu sein. Die zu bearbeitenden Stellen im Code sind mit \/\/ TODO oder &lt;!-- TODO --&gt; markiert. Erstellen Sie f\u00fcr jedes Element in der JSON-Gru\u00dfformelvorlage eine neue data-Variable. Benutzen Sie den Namen der Elements auch als Name f\u00fcr die Variablen \u00dcbertragen Sie Werte f\u00fcr die Elemente per Hand in die Variable. Ersetzen Sie die hartgecodeten Informationen zur Gru\u00dfformel im HTML-Bereich mit VueJS-Templates {{ }} an den passenden Stellen. Auch HTML-Attribute k\u00f6nnen VueJS-Variablen zugewiesen werden. Denken Sie dabei an ein Beispiel aus einer vergangenen Challenge zur\u00fcck: &lt;button v-bind:disabled=&quot;!isValidNewItem&quot;&gt;Hinzuf\u00fcgen&lt;\/button&gt;","tags":"","url":"eXist-db_und_VueJS\/Challenge_1_-_Datenstruktur_und_Templates_anlegen.html"},{"title":"Challenge 1 - L\u00f6sung","text":"Challenge 1: L\u00f6sung JavaScript HTML Code Challenge 1: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 1: Datenstruktur und Templates anlegen. JavaScript Die JSON-Gru\u00dfformel aus dem vorigen Abschnitt wurde in VueJS-Variablen \u00fcbersetzt. Nun sind diese Variablen nachnutzbar. const vue = new Vue({ el: '#quoteSalute', data: { quote: 'Mit Verehrung Ihr ergebenster etc.', edition: 'Jean Paul \u2013 S\u00e4mtliche Briefe digital', title: 'An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.', url: 'https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612', language: 'deu', license: null } }); HTML Die hartgecodeten Zeichenketten wurden durch die entsprechenden Variablen ersetzt. Statt der Gru\u00dfformel &quot;Mit Verehrung Ihr ergebenster etc.&quot; wird nun auf die entsprechende Variable {{ quote }} zur\u00fcckgegriffen. Um die url-Variable ans href-Attribut anzubinden, wurde die v-bind-Direktive, bzw. dessen Kurzform genutzt. &lt;a v-bind:href=&quot;url&quot; class=&quot;card-link&quot; target=&quot;_blank&quot;&gt;Zum Originalbrief&lt;\/a&gt; &lt;div id=&quot;quoteSalute&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;{{ edition }}&lt;\/h5&gt; &lt;h6 class=&quot;card-subtitle mb-2 text-muted&quot;&gt;{{ title }}&lt;\/h6&gt; &lt;p class=&quot;card-text&quot;&gt;&lt;em&gt;{{ quote }}&lt;\/em&gt;&lt;\/p&gt; &lt;a :href=&quot;url&quot; class=&quot;card-link&quot; target=&quot;_blank&quot;&gt;Zum Originalbrief&lt;\/a&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; Code &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: quoteSalute&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;quoteSalute&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;quoteSalute&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;{{ edition }}&lt;\/h5&gt; &lt;h6 class=&quot;card-subtitle mb-2 text-muted&quot;&gt;{{ title }}&lt;\/h6&gt; &lt;p class=&quot;card-text&quot;&gt;&lt;em&gt;{{ quote }}&lt;\/em&gt;&lt;\/p&gt; &lt;a :href=&quot;url&quot; class=&quot;card-link&quot; target=&quot;_blank&quot;&gt;Zum Originalbrief&lt;\/a&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#quoteSalute', data: { quote: 'Mit Verehrung Ihr ergebenster etc.', edition: 'Jean Paul \u2013 S\u00e4mtliche Briefe digital', title: 'An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.', url: 'https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612', language: 'deu', license: null } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"eXist-db_und_VueJS\/Challenge_1_-_L\u00f6sung.html"},{"title":"Aktionen beim Start","text":"Aktionen beim Start Eine neue Gru\u00dfformel created Aktionen beim Start In diesem Abschnitt wird vorgestellt, wie bestimmte VueJS-Operationen bereits beim Start der Instanz ausgef\u00fchrt werden. Zugeh\u00f6rige Beispieldatei: 06_Aktionen_beim_Start.html Eine neue Gru\u00dfformel \u00d6ffnen Sie die Beispieldatei 06_Aktionen_beim_Start.html. Warum wird eine neue Gru\u00dfformel angezeigt? created Neben data, methods und computed gibt es noch weitere M\u00f6glichkeiten eine VueJS-Instanz auszugestalten. Legt man eine created() Funktion an, wird der Inhalt dieser Funktion ausgef\u00fchrt, sobald die VueJS-Instanz vom Browser geladen wurde. Das untenstehende Beispiel l\u00e4uft wie folgt ab: Lade das data-Element. Der Wert von quote ist &quot;Mit Verehrung Ihr ergebenster etc.&quot;. Pr\u00fcfe, ob es eine created()-Funktion gibt. Ja, also f\u00fchre Sie aus. In der created()-Funktion wird der Wert von quote mit &quot;Eine neue Gru\u00dfformel&quot;. Jetzt ist die VueJS-Instanz bereit zum Rendern. Wie wird die Gru\u00dfformel lauten, die angezeigt wird? const vue = new Vue({ el: '#quoteSalute', data: { quote: 'Mit Verehrung Ihr ergebenster etc.', edition: 'Jean Paul \u2013 S\u00e4mtliche Briefe digital', title: 'An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.', url: 'https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612', language: 'deu', license: null }, methods: { \/\/ ... }, computed: { \/\/ ... }, created() { this.quote = 'Eine neue Gru\u00dfformel' } });","tags":"","url":"eXist-db_und_VueJS\/Aktionen_beim_Start.html"},{"title":"VueJS an eXist-db anbinden","text":"VueJS an eXist-db anbinden vue-resource VueJS an eXist-db anbinden In diesem Abschnitt wird gezeigt, wie man mit vue-resource in einer VueJS-Instanz Daten asynchron von einer eXist-db-Instanz abruft und verarbeitet. Zugeh\u00f6rige Beispieldatei: 03_quoteSalute_Basisvorlage.html vue-resource Die Funktionalit\u00e4t von VueJS wird durch eine Zusatzbibliothek ab diesem Abschnitt erweitert. Nachdem VueJS importiert wird, importieren wir anschlie\u00dfend vue-resource. &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script src=&quot;js\/vue-resource.js&quot;&gt;&lt;\/script&gt; vue-resource erlaubt es uns, asynchrone Anfragen (sog. AJAX-Requests) an einen Server zu senden. W\u00e4hrend Sie also bereits mit dem Browser eine Webseite ge\u00f6ffnet haben, werden im Hintergrund zus\u00e4tzliche Informationen vom selben oder anderen Servern geladen, um die Webseite mit neuen Informationen zu f\u00fcttern. Wir benutzen vue-resource um neue Gru\u00dfformeln von unserem quoteSalute-Back-End zu holen und in unserer VueJS-Instanz nutzbar zu machen.","tags":"","url":"eXist-db_und_VueJS\/VueJS_an_eXist-db_anbinden.html"},{"title":"Challenge 2 - Neue Gru\u00dfformel zum Start","text":"Challenge 2: Neue Gru\u00dfformel zum Start Aufgabe L\u00f6sungsans\u00e4tze Challenge 2: Neue Gru\u00dfformel zum Start Zugeh\u00f6rige Beispieldatei: 08_Challenge_2.html Im vorherigen Abschnitt wurde die VueJS-Instanz um vue-resource erweitert, sodass man innerhalb einer VueJS-Instanz sog. AJAX-Requests ausf\u00fchren kann. In der created()-Methode wurde bereits ein Skelett angelegt, um von der quoteSalute-API eine neue Gru\u00dfformel abzurufen. Aufgabe Erweitern Sie die created()-Funktion bzw. den AJAX-Request mit vue-resource so, dass s\u00e4mtliche Informationen zu einer Gru\u00dfformel in den data-Variablen gespeichert werden. L\u00f6sungsans\u00e4tze \u00d6ffnen Sie die Datei 08_Challenge_8.html sowohl mit einem Editor und Browser. Wenn das Ergebnis bei jedem Neuladen des Browsertabs anders aussieht, scheint Ihr Ergebnis richtig zu sein. Die zu bearbeitenden Stellen im Code sind mit \/\/ TODO markiert. Orientieren Sie sich an der JSON-Datenstruktur. Tipp: Nutzen Sie die Entwicklerwerkzeuge Ihres Browsers. Dr\u00fccken Sie F12. Gehen Sie auf den Tab Netzwerkanalyse. Klicken Sie auf XHR. Laden Sie die Seite neu. Es sollte ein Eintrag erscheinen. Klicken Sie auf diesen. Klicken Sie auf Antwort. Das Ergebnis des asynchronen Requests wird Ihnen dort angezeigt.","tags":"","url":"eXist-db_und_VueJS\/Challenge_2_-_Neue_Gru\u00dfformel_zum_Start.html"},{"title":"Challenge 2 - L\u00f6sung","text":"Challenge 2: L\u00f6sung JavaScript Challenge 2: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 2: Neue Gru\u00dfformel zum Start. Zugeh\u00f6rige Beispieldatei: 09_Challenge_2_Solution.html Bei jedem Neuladen der Seite wird eine neue Gru\u00dfformel geholt. JavaScript F\u00fcr jede Variable im data-Objekt wurde der Prozess des \u00dcberschreibens der Werte analog wiederholt. created() { this.$http.get('https:\/\/correspsearch.net\/quotesalute\/abfrage.xql').then(response =&gt; { this.quote = response.data.quote; this.edition = response.data.edition; this.title = response.data.title; this.url = response.data.url; this.license = response.data.license }); }","tags":"","url":"eXist-db_und_VueJS\/Challenge_2_-_L\u00f6sung.html"},{"title":"Challenge 3 - Neue Gru\u00dfformel auf Knopfdruck","text":"Challenge 2: Neue Gru\u00dfformel auf Knopfdruck Aufgabe Vorgehensweise Bonusaufgabe Challenge 2: Neue Gru\u00dfformel auf Knopfdruck Zugeh\u00f6rige Beispieldatei: 10_Challenge_3.html Aufgabe Statt immer die Seite neu Laden zu m\u00fcssen, soll eine neue Gru\u00dfformel auf Knopfdruck geholt werden. Vorgehensweise \u00d6ffnen Sie die Datei 08_Challenge_8.html sowohl mit einem Editor und Browser. Wenn das Ergebnis bei jedem Druck auf den neuen Knopf anders aussieht, scheint Ihr Ergebnis richtig zu sein. Die zu bearbeitenden Stellen im Code sind mit \/\/ TODO und ` markiert. Legen Sie den methods-Bereich der VueJS-Instanz an Erstellen Sie eine Funktion fetchSalute() und nutzen Sie den Code aus der created()-Methode nach. Erstellen Sie im HTML-Bereich an der markierten Stelle einen Button mit der Aufschrit Neu und verbinden Sie ihn mit der fetchSalute()-Funktion \u00fcber v-on:click. Bonusaufgabe Verk\u00fcrzen Sie den Inhalt der created()-Methode. Brauch man den Code wirklich zwei Mal?","tags":"","url":"eXist-db_und_VueJS\/Challenge_3_-_Neue_Gru\u00dfformel_auf_Knopfdruck.html"},{"title":"Challenge 3 - L\u00f6sung","text":"Challenge 3: L\u00f6sung JavaScript HTML Code Challenge 3: L\u00f6sung Hier ist unsere Musterl\u00f6sung zur Challenge 3: Neue Gru\u00dfformel auf Knopfdruck. Zugeh\u00f6rige Beispieldatei: 11_Challenge_3_Solution.html. Bei Druck auf den Neu-Button wird eine neue Gru\u00dfformel geholt. JavaScript Der Code zum Abrufen einer neuen Gru\u00dfformel wurde in die Methode fetchSalute() umgelagert. In der created()-Methode wird fetchSalute() einfach aufgerufen. const vue = new Vue({ el: '#quoteSalute', data: { quote: 'Mit Verehrung Ihr ergebenster etc.', edition: 'Jean Paul \u2013 S\u00e4mtliche Briefe digital', title: 'An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.', url: 'https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612', language: 'deu', license: null }, methods: { fetchSalute() { this.$http.get('https:\/\/correspsearch.net\/quotesalute\/abfrage.xql').then(response =&gt; { this.quote = response.data.quote; this.edition = response.data.edition; this.title = response.data.title; this.url = response.data.url; this.license = response.data.license }); } }, created() { this.fetchSalute(); } }); HTML Es wurde ein neuer Button eingerichtet. Die fetchSalute()-Methode wird ausgef\u00fchrt, wenn er geklickt wird (v-on:click). &lt;button class=&quot;btn btn-primary&quot; v-on:click=&quot;fetchSalute&quot;&gt;Neu&lt;\/button&gt; Code &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: quoteSalute&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;quoteSalute&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;quoteSalute&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;{{ edition }}&lt;\/h5&gt; &lt;h6 class=&quot;card-subtitle mb-2 text-muted&quot;&gt;{{ title }}&lt;\/h6&gt; &lt;p class=&quot;card-text&quot;&gt;&lt;em&gt;{{ quote }}&lt;\/em&gt;&lt;\/p&gt; &lt;a :href=&quot;url&quot; class=&quot;card-link&quot; target=&quot;_blank&quot;&gt;Zum Originalbrief&lt;\/a&gt; &lt;div&gt; &lt;button class=&quot;btn btn-primary&quot; v-on:click=&quot;fetchSalute&quot;&gt;Neu&lt;\/button&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script src=&quot;js\/vue-resource.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const vue = new Vue({ el: '#quoteSalute', data: { quote: 'Mit Verehrung Ihr ergebenster etc.', edition: 'Jean Paul \u2013 S\u00e4mtliche Briefe digital', title: 'An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.', url: 'https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612', language: 'deu', license: null }, methods: { fetchSalute() { this.$http.get('https:\/\/correspsearch.net\/quotesalute\/abfrage.xql').then(response =&gt; { this.quote = response.data.quote; this.edition = response.data.edition; this.title = response.data.title; this.url = response.data.url; this.license = response.data.license }); } }, created() { this.fetchSalute(); } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"eXist-db_und_VueJS\/Challenge_3_-_L\u00f6sung.html"},{"title":"Bonus - Gru\u00dfformeln filtern","text":"Gru\u00dfformeln filtern Datenmodell erweitern Check-Boxen einrichten Anfrage anpassen mit computed Parameters Code Gru\u00dfformeln filtern In diesem Abschnitt wird gezeigt, wie Filter auf die Gru\u00dfformel-Abfrage angewendet werden k\u00f6nnen. Zugeh\u00f6rige Beispieldatei: 12_Challenge_3_-_Solution.html. Datenmodell erweitern In diesem Beispiel wird ein Filter zum Ausw\u00e4hlen der Sprache der Gru\u00dfformel eingerichtet. Zuerst erweitern wir das Datenmodell data der VueJS-Instanz mit filterLanguage. const vue = new Vue({ el: '#quoteSalute', data: { quote: 'Mit Verehrung Ihr ergebenster etc.', edition: 'Jean Paul \u2013 S\u00e4mtliche Briefe digital', title: 'An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.', url: 'https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612', language: 'deu', license: null, \/\/ Siehe hier filterLanguage: [] }, created() { this.$http.get('https:\/\/correspsearch.net\/quotesalute\/abfrage.xql').then(response =&gt; { this.quote = response.data.quote; this.edition = response.data.edition; this.title = response.data.title; this.url = response.data.url; this.license = response.data.license }); } }); Check-Boxen einrichten Es werden Check-Box-Inputs eingerichtet, f\u00fcr die Sprachen Deutsch, Englisch und Italienisch. Mit v-model=&quot;filterLanguage&quot;. Mit dem value-Attribut f\u00fcgen wir einen Wert hinzu. Wird eine Check-Box angeklickt, wird der dazugeh\u00f6rige Wert in das filterLanguage-Array geschrieben. Keine Haken: [] nur Deutsch: ['deu'] Deutsch und Englisch: ['deu', 'eng'] usw. &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Sprache&lt;\/h5&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;form-check&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;languageDeu&quot; value=&quot;deu&quot; v-model=&quot;filterLanguage&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;sender-female&quot;&gt;Deutsch&lt;\/label&gt; &lt;\/div&gt; &lt;div class=&quot;form-check&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;languageEng&quot; value=&quot;eng&quot; v-model=&quot;filterLanguage&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;sender-male&quot;&gt;Englisch&lt;\/label&gt; &lt;\/div&gt; &lt;div class=&quot;form-check&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;languageIta&quot; value=&quot;ita&quot; v-model=&quot;filterLanguage&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;sender-neutral&quot;&gt;Italienisch&lt;\/label&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; Anfrage anpassen mit computed Parameters Im Anfangskapitel zu eXist-db wurde das Filter-Prinzip von quoteSalute im Back-End bereits erkl\u00e4rt. Bevor die VueJs-Instanz initialisiert wird, legen wir noch eine Liste mit allen verf\u00fcgbaren Sprachen an. const allLanguages = ['deu','eng','spa','fra','ita', 'grc', 'lat']; Das Back-End zerlegt mehrere Angaben zu einer Filterkategorie, indem die Werte durch X getrennt sind. Der folgende computed-Wert languageParams verbindetet alle m\u00f6glichen Spracheintr\u00e4ge mit einem X, wenn kein Sprachfilter gesetzt wurde. Wurde jedoch eine oder mehrere Sprachen ausgew\u00e4hlt, verbindet er nur die ausgew\u00e4hlten. computed: { languageParams() { if (this.filterLanguage.length) { return this.filterLanguage.join('X') } return allLanguages.join('X'); } } In der fetchSalute()-Methode teilen wir vue-http mit, dass URL-Parameter \u00fcbergeben werden sollen. vue-http passt die Anzufragende URL dann automatisch an. Sind keine Filter gesetzt, wird die dann folgende URL abgefragt: https:\/\/correspsearch.net\/quotesalute\/abfrage.xql?language=deuXengXspaXfraXitaXgrcXlat Ist z.B. nur Deutsch ausgew\u00e4hlt, wird folgende URL abgefragt: https:\/\/correspsearch.net\/quotesalute\/abfrage.xql?language=deu methods: { fetchSalute() { this.$http.get('https:\/\/correspsearch.net\/quotesalute\/abfrage.xql', { params: { language: this.languageParams } }).then(response =&gt; { this.quote = response.data.quote; this.edition = response.data.edition; this.title = response.data.title; this.url = response.data.url; this.license = response.data.license }); } }, Code &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css\/bootstrap.min.css&quot;&gt; &lt;title&gt;DHd19: quoteSalute&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;header class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot; style=&quot;margin-bottom:20px&quot;&gt;quoteSalute&lt;\/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;quoteSalute&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;{{ edition }}&lt;\/h5&gt; &lt;h6 class=&quot;card-subtitle mb-2 text-muted&quot;&gt;{{ title }}&lt;\/h6&gt; &lt;p class=&quot;card-text&quot;&gt;&lt;em&gt;{{ quote }}&lt;\/em&gt;&lt;\/p&gt; &lt;a :href=&quot;url&quot; class=&quot;card-link&quot; target=&quot;_blank&quot;&gt;Zum Originalbrief&lt;\/a&gt; &lt;div&gt; &lt;button class=&quot;btn btn-primary&quot; v-on:click=&quot;fetchSalute&quot;&gt;Neu&lt;\/button&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Sprache&lt;\/h5&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;form-check&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;languageDeu&quot; value=&quot;deu&quot; v-model=&quot;filterLanguage&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;sender-female&quot;&gt;Deutsch&lt;\/label&gt; &lt;\/div&gt; &lt;div class=&quot;form-check&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;languageEng&quot; value=&quot;eng&quot; v-model=&quot;filterLanguage&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;sender-male&quot;&gt;Englisch&lt;\/label&gt; &lt;\/div&gt; &lt;div class=&quot;form-check&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;languageIta&quot; value=&quot;ita&quot; v-model=&quot;filterLanguage&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;sender-neutral&quot;&gt;Italienisch&lt;\/label&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;\/div&gt; &lt;script src=&quot;js\/vue.js&quot;&gt;&lt;\/script&gt; &lt;script src=&quot;js\/vue-resource.js&quot;&gt;&lt;\/script&gt; &lt;script&gt; const allLanguages = ['deu','eng','spa','fra','ita', 'grc', 'lat']; const vue = new Vue({ el: '#quoteSalute', data: { quote: 'Mit Verehrung Ihr ergebenster etc.', edition: 'Jean Paul \u2013 S\u00e4mtliche Briefe digital', title: 'An Friederike Christiane Elisabeth von Ompteda. Bayreuth, 24. Dezember 1819.', url: 'https:\/\/jeanpaul-edition.de\/brief.html?num=VII_612', language: 'deu', license: null, filterLanguage: [] }, computed: { languageParams() { if (this.filterLanguage.length) { return this.filterLanguage.join('X') } return allLanguages.join('X'); } }, methods: { fetchSalute() { this.$http.get('https:\/\/correspsearch.net\/quotesalute\/abfrage.xql', { params: { language: this.languageParams } }).then(response =&gt; { this.quote = response.data.quote; this.edition = response.data.edition; this.title = response.data.title; this.url = response.data.url; this.license = response.data.license }); } }, created() { this.fetchSalute(); } }); &lt;\/script&gt; &lt;\/body&gt; &lt;\/html&gt;","tags":"","url":"eXist-db_und_VueJS\/Bonus_-_Gru\u00dfformeln_filtern.html"},{"title":"Zusammenfassung","text":"\u00dcbersicht \u00dcbersicht In diesem Abschnitt haben Sie gelernt, wie man die Datenstruktur von quoteSalute in VueJS nutzbar macht, VueJS an eine eXist-db mit vue-resource anbindet, Filterm\u00f6glichkeiten und Parameter\u00fcbergaben implementiert. Es gab drei Challenges: Challenge 1: Datenstrukturen und Templates anlegen Challenge 2: Neue Gru\u00dfformel zum Start Challenge 3: Neue Gru\u00dfformel auf Knopfdruck","tags":"","url":"eXist-db_und_VueJS\/Zusammenfassung.html"}]}